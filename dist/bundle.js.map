{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://alt1-loot-tracker/webpack/bootstrap","webpack://alt1-loot-tracker/webpack/runtime/global","webpack://alt1-loot-tracker/./node_modules/@alt1/base/dist/imgref.js","webpack://alt1-loot-tracker/./node_modules/@alt1/base/dist/imagedetect.js","webpack://alt1-loot-tracker/./node_modules/@alt1/base/dist/wrapper.js","webpack://alt1-loot-tracker/./node_modules/@alt1/base/dist/nodepolyfill.js","webpack://alt1-loot-tracker/./node_modules/@alt1/base/dist/imagedata-extensions.js","webpack://alt1-loot-tracker/./node_modules/@alt1/base/dist/rect.js","webpack://alt1-loot-tracker/./node_modules/@alt1/ocr/dist/index.js","webpack://alt1-loot-tracker/./src/ocr.ts","webpack://alt1-loot-tracker/./src/phash.ts","webpack://alt1-loot-tracker/./src/alt1region.ts","webpack://alt1-loot-tracker/./src/storage.ts","webpack://alt1-loot-tracker/./src/ui.ts","webpack://alt1-loot-tracker/./src/index.ts","webpack://alt1-loot-tracker/./src/lootTracker.ts"],"sourcesContent":["// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","import { ImageDetect, transferImageData } from \"./index.js\";\r\n/**\r\n * Represents an image that might be in different types of memory\r\n * This is mostly used to represent images still in Alt1 memory that have\r\n * not been transfered to js yet. Various a1lib api's use this type and\r\n * choose the most efficient approach based on the memory type\r\n */\r\nexport class ImgRef {\r\n    constructor(x, y, w, h) {\r\n        this.t = \"none\";\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = w;\r\n        this.height = h;\r\n    }\r\n    read(x = 0, y = 0, w = this.width, h = this.height) {\r\n        throw new Error(\"This imgref (\" + this.t + \") does not support toData\");\r\n    }\r\n    findSubimage(needle, sx = 0, sy = 0, w = this.width, h = this.height) {\r\n        return ImageDetect.findSubimage(this, needle, sx, sy, w, h);\r\n    }\r\n    toData(x = this.x, y = this.y, w = this.width, h = this.height) {\r\n        return this.read(x - this.x, y - this.y, w, h);\r\n    }\r\n    ;\r\n    containsArea(rect) {\r\n        return this.x <= rect.x && this.y <= rect.y && this.x + this.width >= rect.x + rect.width && this.y + this.height >= rect.y + rect.height;\r\n    }\r\n}\r\n/**\r\n * Represents an image in js render memory (canvas/image tag)\r\n */\r\nexport class ImgRefCtx extends ImgRef {\r\n    constructor(img, x = 0, y = 0) {\r\n        if (img instanceof CanvasRenderingContext2D) {\r\n            super(x, y, img.canvas.width, img.canvas.height);\r\n            this.ctx = img;\r\n        }\r\n        else {\r\n            super(x, y, img.width, img.height);\r\n            var cnv = (img instanceof HTMLCanvasElement ? img : img.toCanvas());\r\n            this.ctx = cnv.getContext(\"2d\");\r\n        }\r\n        this.t = \"ctx\";\r\n    }\r\n    read(x = 0, y = 0, w = this.width, h = this.height) {\r\n        return this.ctx.getImageData(x, y, w, h);\r\n    }\r\n}\r\n/**\r\n * Represents in image in Alt1 memory, This type of image can be searched for subimages\r\n * very efficiently and transfering the full image to js can be avoided this way\r\n */\r\nexport class ImgRefBind extends ImgRef {\r\n    constructor(handle, x = 0, y = 0, w = 0, h = 0) {\r\n        super(x, y, w, h);\r\n        this.handle = handle;\r\n        this.t = \"bind\";\r\n    }\r\n    read(x = 0, y = 0, w = this.width, h = this.height) {\r\n        return transferImageData(this.handle, x, y, w, h);\r\n    }\r\n}\r\n/**\r\n * Represents an image in js memory\r\n */\r\nexport class ImgRefData extends ImgRef {\r\n    constructor(buf, x = 0, y = 0) {\r\n        super(x, y, buf.width, buf.height);\r\n        this.buf = buf;\r\n        this.t = \"data\";\r\n    }\r\n    read(x = 0, y = 0, w = this.width, h = this.height) {\r\n        if (x == 0 && y == 0 && w == this.width && h == this.height) {\r\n            return this.buf;\r\n        }\r\n        var r = new ImageData(w, h);\r\n        for (var b = y; b < y + h; b++) {\r\n            for (var a = x; a < x + w; a++) {\r\n                var i1 = (a - x) * 4 + (b - y) * w * 4;\r\n                var i2 = a * 4 + b * 4 * this.buf.width;\r\n                r.data[i1] = this.buf.data[i2];\r\n                r.data[i1 + 1] = this.buf.data[i2 + 1];\r\n                r.data[i1 + 2] = this.buf.data[i2 + 2];\r\n                r.data[i1 + 3] = this.buf.data[i2 + 3];\r\n            }\r\n        }\r\n        return r;\r\n    }\r\n}\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { ImgRefBind } from \"./imgref.js\";\r\nimport * as wapper from \"./wrapper.js\";\r\nimport * as nodeimports from \"./nodepolyfill.js\";\r\nimport { Rect } from \"./index.js\";\r\n/**\r\n* Downloads an image and returns the ImageData\r\n* Make sure the png image does not have a sRGB chunk or the resulting pixels will differ for different users!!!\r\n* @param url http(s) or data url to the image\r\n*/\r\nexport function imageDataFromUrl(url) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (typeof Image != \"undefined\") {\r\n            var img = new Image();\r\n            img.crossOrigin = \"crossorigin\";\r\n            return yield new Promise((done, fail) => {\r\n                img.onload = function () { done(img.toBuffer()); };\r\n                img.onerror = fail;\r\n                img.src = url;\r\n            });\r\n        }\r\n        else {\r\n            var hdr = \"data:image/png;base64,\";\r\n            if (url.startsWith(hdr)) {\r\n                return imageDataFromBase64(url.slice(hdr.length));\r\n            }\r\n            throw new Error(\"loading remote images in nodejs has been disabled, load the raw bytes and use imageDataFromNodeBuffer instead\");\r\n        }\r\n    });\r\n}\r\n/**\r\n* Loads an ImageData object from a base64 encoded png image\r\n* Make sure the png image does not have a sRGB chunk or the resulting pixels will differ for different users!!!\r\n* @param data a base64 encoded png image\r\n*/\r\nexport function imageDataFromBase64(data) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (typeof Image != \"undefined\") {\r\n            return imageDataFromUrl(\"data:image/png;base64,\" + data);\r\n        }\r\n        else {\r\n            return nodeimports.imageDataFromBase64(data);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Loads an ImageData object directly from a png encoded file buffer\r\n * This method ensures that png color space headers are taken care off\r\n * @param data The bytes of a png file\r\n */\r\nexport function imageDataFromFileBuffer(data) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        clearPngColorspace(data);\r\n        if (typeof Image != \"undefined\") {\r\n            let blob = new Blob([data], { type: \"image/png\" });\r\n            let url = URL.createObjectURL(blob);\r\n            let r = yield imageDataFromUrl(url);\r\n            URL.revokeObjectURL(url);\r\n            return r;\r\n        }\r\n        else {\r\n            return nodeimports.imageDataFromBuffer(data);\r\n        }\r\n    });\r\n}\r\n/**\r\n* Checks if a given byte array is a png file (by checking for ?PNG as first 4 bytes)\r\n* @param bytes Raw bytes of the png file\r\n*/\r\nexport function isPngBuffer(bytes) {\r\n    return bytes[0] == 137 && bytes[1] == 80 && bytes[2] == 78 && bytes[3] == 71;\r\n}\r\n/**\r\n* Resets the colorspace data in the png file.\r\n* This makes sure the browser renders the exact colors in the file instead of filtering it in order to obtain the best real life representation of\r\n* what it looked like on the authors screen. (this feature is often broken and not supported)\r\n* For example a round trip printscreen -> open in browser results in different colors than the original\r\n* @param data Raw bytes of the png file\r\n*/\r\nexport function clearPngColorspace(data) {\r\n    if (!isPngBuffer(data)) {\r\n        throw new Error(\"non-png image received\");\r\n    }\r\n    var i = 8;\r\n    while (i < data.length) {\r\n        var length = data[i++] * 0x1000000 + data[i++] * 0x10000 + data[i++] * 0x100 + data[i++];\r\n        var ancillary = !!((data[i] >> 5) & 1);\r\n        var chunkname = String.fromCharCode(data[i], data[i + 1], data[i + 2], data[i + 3]);\r\n        var chunkid = chunkname.toLowerCase();\r\n        if (chunkid != \"trns\" && ancillary) {\r\n            data[i + 0] = \"n\".charCodeAt(0);\r\n            data[i + 1] = \"o\".charCodeAt(0);\r\n            data[i + 2] = \"P\".charCodeAt(0);\r\n            data[i + 3] = \"E\".charCodeAt(0);\r\n            //calculate new chunk checksum\r\n            //http://www.libpng.org/pub/png/spec/1.2/PNG-CRCAppendix.html\r\n            var end = i + 4 + length;\r\n            var crc = 0xffffffff;\r\n            //should be fast enough like this\r\n            var bitcrc = function (bit) {\r\n                for (var k = 0; k < 8; k++) {\r\n                    if (bit & 1) {\r\n                        bit = 0xedb88320 ^ (bit >>> 1);\r\n                    }\r\n                    else {\r\n                        bit = bit >>> 1;\r\n                    }\r\n                }\r\n                return bit;\r\n            };\r\n            for (var a = i; a < end; a++) {\r\n                if (a >= i + 4) {\r\n                    data[a] = 0;\r\n                }\r\n                var bit = data[a];\r\n                crc = bitcrc((crc ^ bit) & 0xff) ^ (crc >>> 8);\r\n            }\r\n            crc = crc ^ 0xffffffff;\r\n            //new chunk checksum\r\n            data[i + 4 + length + 0] = (crc >> 24) & 0xff;\r\n            data[i + 4 + length + 1] = (crc >> 16) & 0xff;\r\n            data[i + 4 + length + 2] = (crc >> 8) & 0xff;\r\n            data[i + 4 + length + 3] = (crc >> 0) & 0xff;\r\n        }\r\n        if (chunkname == \"IEND\") {\r\n            break;\r\n        }\r\n        i += 4; //type\r\n        i += length; //data\r\n        i += 4; //crc\r\n    }\r\n}\r\n/**\r\n* finds the given needle ImageBuffer in the given haystack ImgRef this function uses the best optimized available\r\n* code depending on the type of the haystack. It will use fast c# searching if the haystack is an ImgRefBind, js searching\r\n* is used otherwise.\r\n* the checklist argument is no longer used and should ignored or null/undefined\r\n* The optional sx,sy,sw,sh arguments indicate a bounding rectangle in which to search the needle. The rectangle should be bigger than the needle\r\n* @returns An array of points where the needle is found. The array is empty if none are found\r\n*/\r\nexport function findSubimage(haystackImgref, needleBuffer, sx = 0, sy = 0, sw = haystackImgref.width, sh = haystackImgref.height) {\r\n    if (!haystackImgref) {\r\n        throw new TypeError();\r\n    }\r\n    if (!needleBuffer) {\r\n        throw new TypeError();\r\n    }\r\n    var max = 30;\r\n    //check if we can do this in alt1\r\n    if (haystackImgref instanceof ImgRefBind && wapper.hasAlt1 && alt1.bindFindSubImg) {\r\n        var needlestr = wapper.encodeImageString(needleBuffer);\r\n        var r = alt1.bindFindSubImg(haystackImgref.handle, needlestr, needleBuffer.width, sx, sy, sw, sh);\r\n        if (!r) {\r\n            throw new wapper.Alt1Error();\r\n        }\r\n        return JSON.parse(r);\r\n    }\r\n    return findSubbuffer(haystackImgref.read(), needleBuffer, sx, sy, sw, sh);\r\n}\r\n/**\r\n* Uses js to find the given needle ImageBuffer in the given haystack ImageBuffer. It is better to use the alt1.bind- functions in\r\n* combination with a1nxt.findsubimg.\r\n* the optional sx,sy,sw,sh arguments indicate a bounding rectangle in which to search.\r\n* @returns An array of points where the needle is found. The array is empty if none are found\r\n*/\r\nexport function findSubbuffer(haystack, needle, sx = 0, sy = 0, sw = haystack.width, sh = haystack.height) {\r\n    var r = [];\r\n    var maxdif = 30;\r\n    var maxresults = 50;\r\n    var needlestride = needle.width * 4;\r\n    var heystackstride = haystack.width * 4;\r\n    //built list of non trans pixel to check\r\n    var checkList = [];\r\n    for (var y = 0; y < needle.height; y++) {\r\n        for (var x = 0; x < needle.width; x++) {\r\n            var i = x * 4 + y * needlestride;\r\n            if (needle.data[i + 3] == 255) {\r\n                checkList.push({ x: x, y: y });\r\n            }\r\n            if (checkList.length == 10) {\r\n                break;\r\n            }\r\n        }\r\n        if (checkList.length == 10) {\r\n            break;\r\n        }\r\n    }\r\n    var cw = (sx + sw) - needle.width;\r\n    var ch = (sy + sh) - needle.height;\r\n    var checklength = checkList.length;\r\n    for (var y = sy; y <= ch; y++) {\r\n        outer: for (var x = sx; x <= cw; x++) {\r\n            for (var a = 0; a < checklength; a++) {\r\n                var i1 = (x + checkList[a].x) * 4 + (y + checkList[a].y) * heystackstride;\r\n                var i2 = checkList[a].x * 4 + checkList[a].y * needlestride;\r\n                var d = 0;\r\n                d = d + Math.abs(haystack.data[i1 + 0] - needle.data[i2 + 0]) | 0;\r\n                d = d + Math.abs(haystack.data[i1 + 1] - needle.data[i2 + 1]) | 0;\r\n                d = d + Math.abs(haystack.data[i1 + 2] - needle.data[i2 + 2]) | 0;\r\n                d *= 255 / needle.data[i2 + 3];\r\n                if (d > maxdif) {\r\n                    continue outer;\r\n                }\r\n            }\r\n            if (simpleCompare(haystack, needle, x, y, maxdif) != Infinity) {\r\n                r.push({ x, y });\r\n                if (r.length > maxresults) {\r\n                    return r;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return r;\r\n}\r\n/**\r\n* Compares two images and returns the average color difference per pixel between them\r\n* @param max The max color difference at any point in the image before short circuiting the function and returning Infinity. set to -1 to always continue.\r\n* @returns The average color difference per pixel or Infinity if the difference is more than max at any point in the image\r\n*/\r\nexport function simpleCompare(bigbuf, checkbuf, x, y, max = 30) {\r\n    if (x < 0 || y < 0) {\r\n        throw new RangeError();\r\n    }\r\n    if (x + checkbuf.width > bigbuf.width || y + checkbuf.height > bigbuf.height) {\r\n        throw new RangeError();\r\n    }\r\n    if (max == -1) {\r\n        max = 255 * 4;\r\n    }\r\n    var dif = 0;\r\n    for (var step = 8; step >= 1; step /= 2) {\r\n        for (var cx = 0; cx < checkbuf.width; cx += step) {\r\n            for (var cy = 0; cy < checkbuf.height; cy += step) {\r\n                var i1 = (x + cx) * 4 + (y + cy) * bigbuf.width * 4;\r\n                var i2 = cx * 4 + cy * checkbuf.width * 4;\r\n                var d = 0;\r\n                d = d + Math.abs(bigbuf.data[i1 + 0] - checkbuf.data[i2 + 0]) | 0;\r\n                d = d + Math.abs(bigbuf.data[i1 + 1] - checkbuf.data[i2 + 1]) | 0;\r\n                d = d + Math.abs(bigbuf.data[i1 + 2] - checkbuf.data[i2 + 2]) | 0;\r\n                d *= checkbuf.data[i2 + 3] / 255;\r\n                if (step == 1) {\r\n                    dif += d;\r\n                }\r\n                if (d > max) {\r\n                    return Infinity;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return dif / checkbuf.width / checkbuf.height;\r\n}\r\n/**\r\n* Calculates the root mean square error between the two buffers at the given coordinate, this method can be used in situations with significant blur or\r\n* transparency, it does not bail early on non-matching images like simpleCompare does so it can be expected to be much slower when called often.\r\n* @returns The root mean square error beteen the images, high single pixel errors are penalized more than consisten low errors. return of 0 means perfect match.\r\n*/\r\nexport function simpleCompareRMSE(bigbuf, checkbuf, x, y) {\r\n    if (x < 0 || y < 0) {\r\n        throw new RangeError();\r\n    }\r\n    if (x + checkbuf.width > bigbuf.width || y + checkbuf.height > bigbuf.height) {\r\n        throw new RangeError();\r\n    }\r\n    var dif = 0;\r\n    var numpix = 0;\r\n    for (var cx = 0; cx < checkbuf.width; cx++) {\r\n        for (var cy = 0; cy < checkbuf.height; cy++) {\r\n            var i1 = (x + cx) * 4 + (y + cy) * bigbuf.width * 4;\r\n            var i2 = cx * 4 + cy * checkbuf.width * 4;\r\n            var d = 0;\r\n            d = d + Math.abs(bigbuf.data[i1 + 0] - checkbuf.data[i2 + 0]) | 0;\r\n            d = d + Math.abs(bigbuf.data[i1 + 1] - checkbuf.data[i2 + 1]) | 0;\r\n            d = d + Math.abs(bigbuf.data[i1 + 2] - checkbuf.data[i2 + 2]) | 0;\r\n            var weight = checkbuf.data[i2 + 3] / 255;\r\n            numpix += weight;\r\n            dif += d * d * weight;\r\n        }\r\n    }\r\n    return Math.sqrt(dif / numpix);\r\n}\r\n/**\r\n* Returns the difference between two colors (scaled to the alpha of the second color)\r\n*/\r\nexport function coldif(r1, g1, b1, r2, g2, b2, a2) {\r\n    return (Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2)) * a2 / 255; //only applies alpha for 2nd buffer!\r\n}\r\n/**\r\n * Turns map of promises into a map that contains the resolved values after loading.\r\n * @param input\r\n */\r\nexport function asyncMap(input) {\r\n    var raw = {};\r\n    var promises = [];\r\n    for (var a in input) {\r\n        if (input.hasOwnProperty(a)) {\r\n            raw[a] = null;\r\n            promises.push(input[a].then(function (a, i) { raw[a] = i; r[a] = i; }.bind(null, a)));\r\n        }\r\n    }\r\n    var r = {};\r\n    var promise = Promise.all(promises).then(() => { r.loaded = true; return r; });\r\n    Object.defineProperty(r, \"loaded\", { enumerable: false, value: false, writable: true });\r\n    Object.defineProperty(r, \"promise\", { enumerable: false, value: promise });\r\n    Object.defineProperty(r, \"raw\", { enumerable: false, value: raw });\r\n    return Object.assign(r, raw);\r\n}\r\n/**\r\n* Same as asyncMap, but casts the properties to ImageData in typescript\r\n*/\r\nexport function webpackImages(input) {\r\n    return asyncMap(input);\r\n}\r\nexport class ImageDataSet {\r\n    constructor() {\r\n        this.buffers = [];\r\n    }\r\n    matchBest(img, x, y, max) {\r\n        let best = null;\r\n        let bestscore = max;\r\n        for (let a = 0; a < this.buffers.length; a++) {\r\n            let score = img.pixelCompare(this.buffers[a], x, y, bestscore);\r\n            if (isFinite(score) && (bestscore == undefined || score < bestscore)) {\r\n                bestscore = score;\r\n                best = a;\r\n            }\r\n        }\r\n        if (best == null) {\r\n            return null;\r\n        }\r\n        return { index: best, score: bestscore };\r\n    }\r\n    static fromFilmStrip(baseimg, width) {\r\n        if ((baseimg.width % width) != 0) {\r\n            throw new Error(\"slice size does not fit in base img\");\r\n        }\r\n        let r = new ImageDataSet();\r\n        for (let x = 0; x < baseimg.width; x += width) {\r\n            r.buffers.push(baseimg.clone(new Rect(x, 0, width, baseimg.height)));\r\n        }\r\n        return r;\r\n    }\r\n    static fromFilmStripUneven(baseimg, widths) {\r\n        let r = new ImageDataSet();\r\n        let x = 0;\r\n        for (let w of widths) {\r\n            r.buffers.push(baseimg.clone(new Rect(x, 0, w, baseimg.height)));\r\n            x += w;\r\n            if (x > baseimg.width) {\r\n                throw new Error(\"sampling filmstrip outside bounds\");\r\n            }\r\n        }\r\n        if (x != baseimg.width) {\r\n            throw new Error(\"unconsumed pixels left in film strip imagedata\");\r\n        }\r\n        return r;\r\n    }\r\n    static fromAtlas(baseimg, slices) {\r\n        let r = new ImageDataSet();\r\n        for (let slice of slices) {\r\n            r.buffers.push(baseimg.clone(slice));\r\n        }\r\n        return r;\r\n    }\r\n}\r\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport Rect from \"./rect.js\";\r\nimport { ImgRefBind } from \"./imgref.js\";\r\nimport { ImageData } from \"./imagedata-extensions.js\";\r\nimport \"./alt1api.js\";\r\n/**\r\n * Thrown when a method is called that can not be used outside of Alt1\r\n */\r\nexport class NoAlt1Error extends Error {\r\n    constructor() {\r\n        super();\r\n        this.message = \"This method can not be ran outside of Alt1\";\r\n    }\r\n}\r\n;\r\n/**\r\n * Thrown when the Alt1 API returns an invalid result\r\n * Errors of a different type are throw when internal Alt1 errors occur\r\n */\r\nexport class Alt1Error extends Error {\r\n}\r\n/**\r\n * The latest Alt1 version\r\n */\r\nexport var newestversion = \"1.5.5\";\r\n/**\r\n * Whether the Alt1 API is available\r\n */\r\nexport var hasAlt1 = (typeof alt1 != \"undefined\");\r\n/**\r\n * The name of the Alt1 interface skin. (Always \"default\" if running in a browser)\r\n */\r\nexport var skinName = hasAlt1 ? alt1.skinName : \"default\";\r\n/**\r\n * Max number of bytes that can be sent by alt1 in one function\r\n * Not completely sure why this number is different than window.alt1.maxtranfer\r\n */\r\nvar maxtransfer = 4000000;\r\n/**\r\n * Open a link in the default browser\r\n * @deprecated use window.open instead\r\n */\r\nexport function openbrowser(url) {\r\n    if (hasAlt1) {\r\n        alt1.openBrowser(url);\r\n    }\r\n    else {\r\n        window.open(url, '_blank');\r\n    }\r\n}\r\n/**\r\n * Throw if Alt1 API is not available\r\n */\r\nexport function requireAlt1() {\r\n    if (!hasAlt1) {\r\n        throw new NoAlt1Error();\r\n    }\r\n}\r\n/**\r\n * Returns an object with a rectangle that spans all screens\r\n */\r\nexport function getdisplaybounds() {\r\n    if (!hasAlt1) {\r\n        return false;\r\n    }\r\n    return new Rect(alt1.screenX, alt1.screenY, alt1.screenWidth, alt1.screenHeight);\r\n}\r\n/**\r\n * gets an imagebuffer with pixel data about the requested region\r\n */\r\nexport function capture(...args) {\r\n    //TODO change null return on error into throw instead (x3)\r\n    if (!hasAlt1) {\r\n        throw new NoAlt1Error();\r\n    }\r\n    var rect = Rect.fromArgs(...args);\r\n    if (alt1.capture) {\r\n        return new ImageData(alt1.capture(rect.x, rect.y, rect.width, rect.height), rect.width, rect.height);\r\n    }\r\n    var buf = new ImageData(rect.width, rect.height);\r\n    if (rect.width * rect.height * 4 <= maxtransfer) {\r\n        var data = alt1.getRegion(rect.x, rect.y, rect.width, rect.height);\r\n        if (!data) {\r\n            return null;\r\n        }\r\n        decodeImageString(data, buf, 0, 0, rect.width, rect.height);\r\n    }\r\n    else {\r\n        //split up the request to to exceed the single transfer limit (for now)\r\n        var x1 = rect.x;\r\n        var ref = alt1.bindRegion(rect.x, rect.y, rect.width, rect.height);\r\n        if (ref <= 0) {\r\n            return null;\r\n        }\r\n        while (x1 < rect.x + rect.width) {\r\n            var x2 = Math.min(rect.x + rect.width, Math.floor(x1 + (maxtransfer / 4 / rect.height)));\r\n            var data = alt1.bindGetRegion(ref, x1, rect.y, x2 - x1, rect.height);\r\n            if (!data) {\r\n                return null;\r\n            }\r\n            decodeImageString(data, buf, x1 - rect.x, 0, x2 - x1, rect.height);\r\n            x1 = x2;\r\n        }\r\n    }\r\n    return buf;\r\n}\r\n/**\r\n * Makes alt1 bind an area of the rs client in memory without sending it to the js client\r\n * returns an imgref object which can be used to get pixel data using the imgreftobuf function\r\n * currently only one bind can exist per app and the ref in (v) will always be 1\r\n */\r\nexport function captureHold(x, y, w, h) {\r\n    x = Math.round(x);\r\n    y = Math.round(y);\r\n    w = Math.round(w);\r\n    h = Math.round(h);\r\n    requireAlt1();\r\n    var r = alt1.bindRegion(x, y, w, h);\r\n    if (r <= 0) {\r\n        throw new Alt1Error(\"capturehold failed\");\r\n    }\r\n    return new ImgRefBind(r, x, y, w, h);\r\n}\r\n/**\r\n * Same as captureHoldRegion, but captures the screen instead of the rs client. it also uses screen coordinates instead and can capture outside of the rs client\r\n */\r\nexport function captureHoldScreen(x, y, w, h) {\r\n    x = Math.round(x);\r\n    y = Math.round(y);\r\n    w = Math.round(w);\r\n    h = Math.round(h);\r\n    requireAlt1();\r\n    var r = alt1.bindScreenRegion(x, y, w, h);\r\n    if (r <= 0) {\r\n        return false;\r\n    }\r\n    return new ImgRefBind(r, x, y, w, h);\r\n}\r\n/**\r\n * bind the full rs window if the rs window can be detected by alt1, otherwise return the full screen\r\n */\r\nexport function captureHoldFullRs() {\r\n    return captureHold(0, 0, alt1.rsWidth, alt1.rsHeight);\r\n}\r\n/**\r\n * returns a subregion from a bound image\r\n * used internally in imgreftobuf if imgref is a bound image\r\n * @deprecated This should be handled internall by the imgrefbind.toData method\r\n */\r\nexport function transferImageData(handle, x, y, w, h) {\r\n    x = Math.round(x);\r\n    y = Math.round(y);\r\n    w = Math.round(w);\r\n    h = Math.round(h);\r\n    requireAlt1();\r\n    if (alt1.bindGetRegionBuffer) {\r\n        return new ImageData(alt1.bindGetRegionBuffer(handle, x, y, w, h), w, h);\r\n    }\r\n    var r = new ImageData(w, h);\r\n    var x1 = x;\r\n    while (true) { //split up the request to to exceed the single transfer limit (for now)\r\n        var x2 = Math.min(x + w, Math.floor(x1 + (maxtransfer / 4 / h)));\r\n        var a = alt1.bindGetRegion(handle, x1, y, x2 - x1, h);\r\n        if (!a) {\r\n            throw new Alt1Error();\r\n        }\r\n        decodeImageString(a, r, x1 - x, 0, x2 - x1, h);\r\n        x1 = x2;\r\n        if (x1 == x + w) {\r\n            break;\r\n        }\r\n        ;\r\n    }\r\n    return r;\r\n}\r\n/**\r\n * decodes a returned string from alt1 to an imagebuffer\r\n */\r\nexport function decodeImageString(imagestring, target, x, y, w, h) {\r\n    var bin = atob(imagestring);\r\n    var bytes = target.data;\r\n    w |= 0;\r\n    h |= 0;\r\n    var offset = 4 * x + 4 * y * target.width;\r\n    var target_width = target.width | 0;\r\n    for (var a = 0; a < w; a++) {\r\n        for (var b = 0; b < h; b++) {\r\n            var i1 = (offset + (a * 4 | 0) + (b * target_width * 4 | 0)) | 0;\r\n            var i2 = ((a * 4 | 0) + (b * 4 * w | 0)) | 0;\r\n            bytes[i1 + 0 | 0] = bin.charCodeAt(i2 + 2 | 0); //fix weird red/blue swap in c#\r\n            bytes[i1 + 1 | 0] = bin.charCodeAt(i2 + 1 | 0);\r\n            bytes[i1 + 2 | 0] = bin.charCodeAt(i2 + 0 | 0);\r\n            bytes[i1 + 3 | 0] = bin.charCodeAt(i2 + 3 | 0);\r\n        }\r\n    }\r\n    return target;\r\n}\r\n/**\r\n * encodes an imagebuffer to a string\r\n */\r\nexport function encodeImageString(buf, sx = 0, sy = 0, sw = buf.width, sh = buf.height) {\r\n    var raw = \"\";\r\n    for (var y = sy; y < sy + sh; y++) {\r\n        for (var x = sx; x < sx + sw; x++) {\r\n            var i = 4 * x + 4 * buf.width * y | 0;\r\n            raw += String.fromCharCode(buf.data[i + 2 | 0]);\r\n            raw += String.fromCharCode(buf.data[i + 1 | 0]);\r\n            raw += String.fromCharCode(buf.data[i + 0 | 0]);\r\n            raw += String.fromCharCode(buf.data[i + 3 | 0]);\r\n        }\r\n    }\r\n    return btoa(raw);\r\n}\r\n/**\r\n * mixes the given color into a single int. This format is used by alt1\r\n */\r\nexport function mixColor(r, g, b, a = 255) {\r\n    return (b << 0) + (g << 8) + (r << 16) + (a << 24);\r\n}\r\nexport function unmixColor(col) {\r\n    var r = (col >> 16) & 0xff;\r\n    var g = (col >> 8) & 0xff;\r\n    var b = (col >> 0) & 0xff;\r\n    return [r, g, b];\r\n}\r\nexport function identifyApp(url) {\r\n    if (hasAlt1) {\r\n        alt1.identifyAppUrl(url);\r\n    }\r\n}\r\nexport function resetEnvironment() {\r\n    hasAlt1 = (typeof alt1 != \"undefined\");\r\n    skinName = hasAlt1 ? alt1.skinName : \"default\";\r\n}\r\nfunction convertAlt1Version(str) {\r\n    var a = str.match(/^(\\d+)\\.(\\d+)\\.(\\d+)$/);\r\n    if (!a) {\r\n        throw new RangeError(\"Invalid version string\");\r\n    }\r\n    return (+a[1]) * 1000 * 1000 + (+a[2]) * 1000 + (+a[3]) * 1;\r\n}\r\nvar cachedVersionInt = -1;\r\n/**\r\n * checks if alt1 is running and at least the given version. versionstr should be a string with the version eg: 1.3.2\r\n * @param versionstr\r\n */\r\nexport function hasAlt1Version(versionstr) {\r\n    if (!hasAlt1) {\r\n        return false;\r\n    }\r\n    if (cachedVersionInt == -1) {\r\n        cachedVersionInt = alt1.versionint;\r\n    }\r\n    return cachedVersionInt >= convertAlt1Version(versionstr);\r\n}\r\n/**\r\n * Gets the current cursor position in the game, returns null if the rs window is not active (alt1.rsActive)\r\n */\r\nexport function getMousePosition() {\r\n    var pos = alt1.mousePosition;\r\n    if (pos == -1) {\r\n        return null;\r\n    }\r\n    return { x: pos >>> 16, y: pos & 0xFFFF };\r\n}\r\n/**\r\n * Registers a given HTML element as a frame border, when this element is dragged by the user the Alt1 frame will resize accordingly\r\n * Use the direction arguements to make a given direction stick to the mouse. eg. Only set left to true to make the element behave as the left border\r\n * Or set all to true to move the whole window. Not all combinations are permitted\r\n */\r\nexport function addResizeElement(el, left, top, right, bot) {\r\n    if (!hasAlt1 || !alt1.userResize) {\r\n        return;\r\n    }\r\n    el.addEventListener(\"mousedown\", function (e) {\r\n        alt1.userResize(left, top, right, bot);\r\n        e.preventDefault();\r\n    });\r\n}\r\n/**\r\n * Add an event listener\r\n */\r\nexport function on(type, listener) {\r\n    if (!hasAlt1) {\r\n        return;\r\n    }\r\n    if (!alt1.events) {\r\n        alt1.events = {};\r\n    }\r\n    if (!alt1.events[type]) {\r\n        alt1.events[type] = [];\r\n    }\r\n    alt1.events[type].push(listener);\r\n}\r\n/**\r\n * Removes an event listener\r\n */\r\nexport function removeListener(type, listener) {\r\n    var elist = hasAlt1 && alt1.events && alt1.events[type];\r\n    if (!elist) {\r\n        return;\r\n    }\r\n    var i = elist.indexOf(listener);\r\n    if (i == -1) {\r\n        return;\r\n    }\r\n    elist.splice(i, 1);\r\n}\r\n/**\r\n * Listens for the event to fire once and then stops listening\r\n * @param event\r\n * @param cb\r\n */\r\nexport function once(type, listener) {\r\n    var fn = (e) => {\r\n        removeListener(type, fn);\r\n        listener(e);\r\n    };\r\n    on(type, fn);\r\n}\r\n;\r\n/**\r\n * Used to read a set of images from a binary stream returned by the Alt1 API\r\n */\r\nexport class ImageStreamReader {\r\n    constructor(reader, ...args) {\r\n        this.framebuffer = null;\r\n        this.pos = 0;\r\n        this.reading = false;\r\n        this.closed = false;\r\n        //paused state\r\n        this.pausedindex = -1;\r\n        this.pausedbuffer = null;\r\n        this.streamreader = reader;\r\n        if (args[0] instanceof ImageData) {\r\n            this.setFrameBuffer(args[0]);\r\n        }\r\n        else if (typeof args[0] == \"number\") {\r\n            this.setFrameBuffer(new ImageData(args[0], args[1]));\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     */\r\n    setFrameBuffer(buffer) {\r\n        if (this.reading) {\r\n            throw new Error(\"can't change framebuffer while reading\");\r\n        }\r\n        this.framebuffer = buffer;\r\n    }\r\n    /**\r\n     * Closes the underlying stream and ends reading\r\n     */\r\n    close() {\r\n        this.streamreader.cancel();\r\n    }\r\n    /**\r\n     * Reads a single image from the stream\r\n     */\r\n    nextImage() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.reading) {\r\n                throw new Error(\"already reading from this stream\");\r\n            }\r\n            if (!this.framebuffer) {\r\n                throw new Error(\"framebuffer not set\");\r\n            }\r\n            this.reading = true;\r\n            var synctime = -Date.now();\r\n            var starttime = Date.now();\r\n            var r = false;\r\n            while (!r) {\r\n                if (this.pausedindex != -1 && this.pausedbuffer) {\r\n                    r = this.readChunk(this.pausedindex, this.framebuffer.data, this.pausedbuffer);\r\n                }\r\n                else {\r\n                    synctime += Date.now();\r\n                    var res = yield this.streamreader.read();\r\n                    synctime -= Date.now();\r\n                    if (res.done) {\r\n                        throw new Error(\"Stream closed while reading\");\r\n                    }\r\n                    var data = res.value;\r\n                    r = this.readChunk(0, this.framebuffer.data, data);\r\n                }\r\n            }\r\n            synctime += Date.now();\r\n            //console.log(\"Decoded async image, \" + this.framebuffer.width + \"x\" + this.framebuffer.height + \" time: \" + (Date.now() - starttime) + \"ms (\" + synctime + \"ms main thread)\");\r\n            this.reading = false;\r\n            return this.framebuffer;\r\n        });\r\n    }\r\n    readChunk(i, framedata, buffer) {\r\n        //very hot code, explicit int32 casting with |0 speeds it up by ~ x2\r\n        i = i | 0;\r\n        var framesize = framedata.length | 0;\r\n        var pos = this.pos;\r\n        var datalen = buffer.length | 0;\r\n        //var data32 = new Float64Array(buffer.buffer);\r\n        //var framedata32 = new Float64Array(framedata.buffer);\r\n        //fix possible buffer misalignment\r\n        //align to 16 for extra loop unrolling\r\n        while (i < datalen) {\r\n            //slow loop, fix alignment and other issues\r\n            while (i < datalen && pos < framesize && (pos % 16 != 0 || !((i + 16 | 0) <= datalen && (pos + 16 | 0) <= framesize))) {\r\n                var rel = pos;\r\n                if (pos % 4 == 0) {\r\n                    rel = rel + 2 | 0;\r\n                }\r\n                if (pos % 4 == 2) {\r\n                    rel = rel - 2 | 0;\r\n                }\r\n                framedata[rel | 0] = buffer[i | 0];\r\n                i = i + 1 | 0;\r\n                pos = pos + 1 | 0;\r\n            }\r\n            //fast unrolled loop for large chunks i wish js had some sort of memcpy\r\n            if (pos % 16 == 0) {\r\n                while ((i + 16 | 0) <= datalen && (pos + 16 | 0) <= framesize) {\r\n                    framedata[pos + 0 | 0] = buffer[i + 2 | 0];\r\n                    framedata[pos + 1 | 0] = buffer[i + 1 | 0];\r\n                    framedata[pos + 2 | 0] = buffer[i + 0 | 0];\r\n                    framedata[pos + 3 | 0] = buffer[i + 3 | 0];\r\n                    framedata[pos + 4 | 0] = buffer[i + 6 | 0];\r\n                    framedata[pos + 5 | 0] = buffer[i + 5 | 0];\r\n                    framedata[pos + 6 | 0] = buffer[i + 4 | 0];\r\n                    framedata[pos + 7 | 0] = buffer[i + 7 | 0];\r\n                    framedata[pos + 8 | 0] = buffer[i + 10 | 0];\r\n                    framedata[pos + 9 | 0] = buffer[i + 9 | 0];\r\n                    framedata[pos + 10 | 0] = buffer[i + 8 | 0];\r\n                    framedata[pos + 11 | 0] = buffer[i + 11 | 0];\r\n                    framedata[pos + 12 | 0] = buffer[i + 14 | 0];\r\n                    framedata[pos + 13 | 0] = buffer[i + 13 | 0];\r\n                    framedata[pos + 14 | 0] = buffer[i + 12 | 0];\r\n                    framedata[pos + 15 | 0] = buffer[i + 15 | 0];\r\n                    //could speed it up another x2 but wouldn't be able to swap r/b swap and possible alignment issues\r\n                    //framedata32[pos / 8 + 0 | 0] = data32[i / 8 + 0 | 0];\r\n                    //framedata32[pos / 8 + 1 | 0] = data32[i / 8 + 1 | 0];\r\n                    //framedata32[pos / 4 + 2 | 0] = data32[i / 4 + 2 | 0];\r\n                    //framedata32[pos / 4 + 3 | 0] = data32[i / 4 + 3 | 0];\r\n                    pos = pos + 16 | 0;\r\n                    i = i + 16 | 0;\r\n                }\r\n            }\r\n            if (pos >= framesize) {\r\n                this.pausedbuffer = null;\r\n                this.pausedindex = -1;\r\n                this.pos = 0;\r\n                if (i != buffer.length - 1) {\r\n                    this.pausedbuffer = buffer;\r\n                    this.pausedindex = i;\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        this.pos = pos;\r\n        this.pausedbuffer = null;\r\n        this.pausedindex = -1;\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Asynchronously captures a section of the game screen\r\n */\r\nexport function captureAsync(...args) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        requireAlt1();\r\n        var rect = Rect.fromArgs(...args);\r\n        if (alt1.captureAsync) {\r\n            let img = yield alt1.captureAsync(rect.x, rect.y, rect.width, rect.height);\r\n            return new ImageData(img, rect.width, rect.height);\r\n        }\r\n        if (!hasAlt1Version(\"1.4.6\")) {\r\n            return capture(rect.x, rect.y, rect.width, rect.height);\r\n        }\r\n        var url = \"https://alt1api/pixel/getregion/\" + encodeURIComponent(JSON.stringify(Object.assign(Object.assign({}, rect), { format: \"raw\", quality: 1 })));\r\n        var res = yield fetch(url);\r\n        var imgreader = new ImageStreamReader(res.body.getReader(), rect.width, rect.height);\r\n        return imgreader.nextImage();\r\n    });\r\n}\r\n/**\r\n * Asynchronously captures multple area's. This method captures the images in the same render frame if possible\r\n * @param areas\r\n */\r\nexport function captureMultiAsync(areas) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        requireAlt1();\r\n        var r = {};\r\n        if (alt1.captureMultiAsync) {\r\n            let bufs = yield alt1.captureMultiAsync(areas);\r\n            for (let a in areas) {\r\n                if (!bufs[a]) {\r\n                    r[a] = null;\r\n                }\r\n                r[a] = new ImageData(bufs[a], areas[a].width, areas[a].height);\r\n            }\r\n            return r;\r\n        }\r\n        var capts = [];\r\n        var captids = [];\r\n        for (var id in areas) {\r\n            if (areas[id]) {\r\n                capts.push(areas[id]);\r\n                captids.push(id);\r\n            }\r\n            else {\r\n                r[id] = null;\r\n            }\r\n        }\r\n        if (capts.length == 0) {\r\n            return r;\r\n        }\r\n        if (!hasAlt1Version(\"1.5.1\")) {\r\n            var proms = [];\r\n            for (var a = 0; a < capts.length; a++) {\r\n                proms.push(captureAsync(capts[a]));\r\n            }\r\n            var results = yield Promise.all(proms);\r\n            for (var a = 0; a < capts.length; a++) {\r\n                r[captids[a]] = results[a];\r\n            }\r\n        }\r\n        else {\r\n            var res = yield fetch(\"https://alt1api/pixel/getregionmulti/\" + encodeURIComponent(JSON.stringify({ areas: capts, format: \"raw\", quality: 1 })));\r\n            var imgreader = new ImageStreamReader(res.body.getReader());\r\n            for (var a = 0; a < capts.length; a++) {\r\n                var capt = capts[a];\r\n                imgreader.setFrameBuffer(new ImageData(capt.width, capt.height));\r\n                r[captids[a]] = yield imgreader.nextImage();\r\n            }\r\n        }\r\n        return r;\r\n    });\r\n}\r\n/**\r\n * Starts capturing a realtime stream of the game. Make sure you keep reading the stream and close it when you're done or Alt1 WILL crash\r\n * @param framecb Called whenever a new frame is decoded\r\n * @param errorcb Called whenever an error occurs, the error is rethrown if not defined\r\n * @param fps Maximum fps of the stream\r\n */\r\nexport function captureStream(x, y, width, height, fps, framecb, errorcb) {\r\n    requireAlt1();\r\n    if (!hasAlt1Version(\"1.4.6\")) {\r\n        throw new Alt1Error(\"This function is not supported in this version of Alt1\");\r\n    }\r\n    var url = \"https://alt1api/pixel/streamregion/\" + encodeURIComponent(JSON.stringify({ x, y, width, height, fps, format: \"raw\" }));\r\n    var res = fetch(url).then((res) => __awaiter(this, void 0, void 0, function* () {\r\n        var reader = new ImageStreamReader(res.body.getReader(), width, height);\r\n        try {\r\n            while (!reader.closed && !state.closed) {\r\n                var img = yield reader.nextImage();\r\n                if (!state.closed) {\r\n                    framecb(img);\r\n                    state.framenr++;\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            if (!state.closed) {\r\n                reader.close();\r\n                if (errorcb) {\r\n                    errorcb(e);\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        if (!reader.closed && state.closed) {\r\n            reader.close();\r\n        }\r\n    }));\r\n    var state = {\r\n        x, y, width, height,\r\n        framenr: 0,\r\n        close: () => { state.closed = true; },\r\n        closed: false,\r\n    };\r\n    return state;\r\n}\r\n","//nodejs and electron polyfills for web api's\r\n//commented out type info as that breaks webpack with optional dependencies\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { ImageData } from \"./index.js\";\r\nimport { clearPngColorspace } from \"./imagedetect.js\";\r\nvar requirefunction = null;\r\n/**\r\n * Call this function to let the libs require extra dependencies on nodejs in order\r\n * to polyfill some browser api's (mostly image compression/decompression)\r\n * `NodePolifill.polyfillRequire(require);` should solve most cases\r\n */\r\nexport function polyfillRequire(requirefn) {\r\n    requirefunction = requirefn;\r\n}\r\nexport function requireSharp() {\r\n    try {\r\n        if (requirefunction) {\r\n            return requirefunction(\"sharp\");\r\n        }\r\n        else {\r\n            return require(/* webpackIgnore: true */ \"sharp\"); // as typeof import(\"sharp\");\r\n        }\r\n    }\r\n    catch (e) { }\r\n    return null;\r\n}\r\nexport function requireNodeCanvas() {\r\n    //attempt to require sharp first, after loading canvas the module sharp fails to load\r\n    requireSharp();\r\n    try {\r\n        if (requirefunction) {\r\n            return requirefunction(\"canvas\");\r\n        }\r\n        else {\r\n            return require(/* webpackIgnore: true */ \"canvas\"); // as typeof import(\"sharp\");\r\n        }\r\n    }\r\n    catch (e) { }\r\n    return null;\r\n}\r\nexport function requireElectronCommon() {\r\n    try {\r\n        if (requirefunction) {\r\n            return requirefunction(\"electron/common\");\r\n        }\r\n        else {\r\n            return require(/* webpackIgnore: true */ \"electron/common\");\r\n        }\r\n    }\r\n    catch (e) { }\r\n    return null;\r\n}\r\nexport function imageDataToDrawable(buf) {\r\n    let nodecnv = requireNodeCanvas();\r\n    if (!nodecnv) {\r\n        throw new Error(\"couldn't find built-in canvas or the module 'canvas'\");\r\n    }\r\n    return new nodecnv.ImageData(buf.data, buf.width, buf.height);\r\n}\r\nexport function createCanvas(w, h) {\r\n    let nodecnv = requireNodeCanvas();\r\n    if (!nodecnv) {\r\n        throw new Error(\"couldn't find built-in canvas or the module 'canvas'\");\r\n    }\r\n    return nodecnv.createCanvas(w, h);\r\n}\r\nfunction flipBGRAtoRGBA(data) {\r\n    for (let i = 0; i < data.length; i += 4) {\r\n        let tmp = data[i + 2];\r\n        data[i + 2] = data[i + 0];\r\n        data[i + 0] = tmp;\r\n    }\r\n}\r\nexport function imageDataToFileBytes(buf, format, quality) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        //use the electron API if we're in electron\r\n        var electronCommon;\r\n        var sharp;\r\n        if (electronCommon = requireElectronCommon()) {\r\n            let nativeImage = electronCommon.nativeImage;\r\n            //need to copy the buffer in order to flip it without destroying the original\r\n            let bufcpy = Buffer.from(buf.data.slice(buf.data.byteOffset, buf.data.byteLength));\r\n            flipBGRAtoRGBA(bufcpy);\r\n            let nativeimg = nativeImage.createFromBitmap(bufcpy, { width: buf.width, height: buf.height });\r\n            return nativeimg.toPNG();\r\n        }\r\n        else if (sharp = requireSharp()) {\r\n            let img = sharp(Buffer.from(buf.data.buffer), { raw: { width: buf.width, height: buf.height, channels: 4 } });\r\n            if (format == \"image/png\") {\r\n                img.png();\r\n            }\r\n            else if (format == \"image/webp\") {\r\n                var opts = { quality: 80 };\r\n                if (typeof quality == \"number\") {\r\n                    opts.quality = quality * 100;\r\n                }\r\n                img.webp(opts);\r\n            }\r\n            else {\r\n                throw new Error(\"unknown image format: \" + format);\r\n            }\r\n            return yield img.toBuffer({ resolveWithObject: false }).buffer;\r\n        }\r\n        throw new Error(\"coulnd't find build-in image compression methods or the module 'electron/common' or 'sharp'\");\r\n    });\r\n}\r\nexport function imageDataFromBase64(base64) {\r\n    return imageDataFromBuffer(Buffer.from(base64, \"base64\"));\r\n}\r\nexport function imageDataFromBuffer(buffer) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        clearPngColorspace(buffer);\r\n        //use the electron API if we're in electron\r\n        var electronCommon;\r\n        var nodecnv;\r\n        if (electronCommon = requireElectronCommon()) {\r\n            let nativeImage = electronCommon.nativeImage;\r\n            let img = nativeImage.createFromBuffer(buffer);\r\n            let pixels = img.toBitmap();\r\n            let size = img.getSize();\r\n            let pixbuf = new Uint8ClampedArray(pixels.buffer, pixels.byteOffset, pixels.byteLength);\r\n            flipBGRAtoRGBA(pixbuf);\r\n            return new ImageData(pixbuf, size.width, size.height);\r\n        }\r\n        else if (nodecnv = requireNodeCanvas()) {\r\n            return new Promise((done, err) => {\r\n                let img = new nodecnv.Image();\r\n                img.onerror = err;\r\n                img.onload = () => {\r\n                    var cnv = nodecnv.createCanvas(img.naturalWidth, img.naturalHeight);\r\n                    var ctx = cnv.getContext(\"2d\");\r\n                    ctx.drawImage(img, 0, 0);\r\n                    var data = ctx.getImageData(0, 0, img.naturalWidth, img.naturalHeight);\r\n                    //use our own class\r\n                    done(new ImageData(data.data, data.width, data.height));\r\n                };\r\n                img.src = Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);\r\n            });\r\n        }\r\n        throw new Error(\"couldn't find built-in canvas, module 'electron/common' or the module 'canvas'\");\r\n    });\r\n}\r\n","import * as a1lib from \"./index.js\";\r\nimport * as nodeimports from \"./nodepolyfill.js\";\r\n//export this so node.js can also use it\r\nexport var ImageData;\r\n// //TODO revamp this madness a bit?\r\n// (function () {\r\n// \tvar globalvar = (typeof self != \"undefined\" ? self : (typeof (global as any) != \"undefined\" ? (global as any) : null)) as any;\r\n// \t//use the node-canvas version when on node\r\n// \tif (typeof globalvar.ImageData == \"undefined\") {\r\n// \t\tlet nodecnv = requireNodeCanvas();\r\n// \t\tglobalvar.ImageData = nodecnv.ImageData;\r\n// \t}\r\n// \tvar fill = typeof globalvar.ImageData == \"undefined\";\r\n// \t//should never be reach anymore\r\n// \tvar constr = function (this: any) {\r\n// \t\tvar i = 0;\r\n// \t\tvar data = (arguments[i] instanceof Uint8ClampedArray ? arguments[i++] : null);\r\n// \t\tvar width = arguments[i++];\r\n// \t\tvar height = arguments[i++];\r\n// \t\tif (fill) {\r\n// \t\t\tif (!data) { data = new Uint8ClampedArray(width * height * 4); }\r\n// \t\t\tthis.width = width;\r\n// \t\t\tthis.height = height;\r\n// \t\t\tthis.data = data;\r\n// \t\t}\r\n// \t\telse if (oldconstr) {\r\n// \t\t\treturn (data ? new oldconstr(data, width, height) : new oldconstr(width, height));\r\n// \t\t} else {\r\n// \t\t\tvar canvas = document.createElement('canvas');\r\n// \t\t\tcanvas.width = width;\r\n// \t\t\tcanvas.height = height;\r\n// \t\t\tvar ctx = canvas.getContext(\"2d\")!;\r\n// \t\t\tvar imageData = ctx.createImageData(width, height);\r\n// \t\t\tif (data) { imageData.data.set(data); }\r\n// \t\t\treturn imageData;\r\n// \t\t}\r\n// \t}\r\n// \tvar oldconstr = globalvar.ImageData;\r\n// \tif (typeof document != \"undefined\") {\r\n// \t\ttry {\r\n// \t\t\tnew oldconstr(1, 1);\r\n// \t\t} catch (e) {\r\n// \t\t\t//direct constructor call not allowed in ie\r\n// \t\t\toldconstr = null;\r\n// \t\t}\r\n// \t}\r\n// \tif (!fill) { constr.prototype = globalvar.ImageData.prototype; }\r\n// \tglobalvar.ImageData = constr;\r\n// \tImageData = constr as any;\r\n// })();\r\n(function () {\r\n    var globalvar = (typeof self != \"undefined\" ? self : (typeof global != \"undefined\" ? global : null));\r\n    var filltype = typeof globalvar.ImageData == \"undefined\" || typeof globalvar.document == \"undefined\";\r\n    var fillconstr = filltype;\r\n    if (!filltype) {\r\n        var oldconstr = globalvar.ImageData;\r\n        try {\r\n            let data = new Uint8ClampedArray(4);\r\n            data[0] = 1;\r\n            let a = new globalvar.ImageData(data, 1, 1);\r\n            fillconstr = a.data[0] != 1;\r\n        }\r\n        catch (e) {\r\n            fillconstr = true;\r\n        }\r\n    }\r\n    if (fillconstr) {\r\n        var constr = function ImageDataShim() {\r\n            var i = 0;\r\n            var data = (arguments[i] instanceof Uint8ClampedArray ? arguments[i++] : null);\r\n            var width = arguments[i++];\r\n            var height = arguments[i++];\r\n            if (filltype) {\r\n                if (!data) {\r\n                    data = new Uint8ClampedArray(width * height * 4);\r\n                }\r\n                this.width = width;\r\n                this.height = height;\r\n                this.data = data;\r\n            }\r\n            else if (fillconstr) {\r\n                //WARNING This branch of code does not use the same pixel data backing store\r\n                //(problem with wasm, however all wasm browser have a native constructor (unless asm.js is used))\r\n                var canvas = document.createElement('canvas');\r\n                canvas.width = width;\r\n                canvas.height = height;\r\n                var ctx = canvas.getContext(\"2d\");\r\n                var imageData = ctx.createImageData(width, height);\r\n                if (data) {\r\n                    imageData.data.set(data);\r\n                }\r\n                return imageData;\r\n            }\r\n            // else {\r\n            // \t//oh no...\r\n            // \t//we need this monstrocity in order to call the native constructor with variable number of args\r\n            // \t//when es5 transpile is enable (that strips the spread operator)\r\n            // \treturn new (Function.prototype.bind.apply(oldconstr, [null,...arguments]));\r\n            // }\r\n        };\r\n        if (!filltype) {\r\n            constr.prototype = globalvar.ImageData.prototype;\r\n        }\r\n        globalvar.ImageData = constr;\r\n        ImageData = constr;\r\n    }\r\n    else {\r\n        ImageData = globalvar.ImageData;\r\n    }\r\n})();\r\n//Recast into a drawable imagedata class on all platforms, into a normal browser ImageData on browsers or a node-canvas imagedata on nodejs\r\nImageData.prototype.toDrawableData = function () {\r\n    if (typeof document == \"undefined\") {\r\n        return nodeimports.imageDataToDrawable(this);\r\n    }\r\n    else {\r\n        return this;\r\n    }\r\n};\r\nImageData.prototype.putImageData = function (buf, cx, cy) {\r\n    for (var dx = 0; dx < buf.width; dx++) {\r\n        for (var dy = 0; dy < buf.height; dy++) {\r\n            var i1 = (dx + cx) * 4 + (dy + cy) * 4 * this.width;\r\n            var i2 = dx * 4 + dy * 4 * buf.width;\r\n            this.data[i1] = buf.data[i2];\r\n            this.data[i1 + 1] = buf.data[i2 + 1];\r\n            this.data[i1 + 2] = buf.data[i2 + 2];\r\n            this.data[i1 + 3] = buf.data[i2 + 3];\r\n        }\r\n    }\r\n};\r\nImageData.prototype.pixelOffset = function (x, y) {\r\n    return x * 4 + y * this.width * 4;\r\n};\r\n//creates a hash of a portion of the buffer used to check for changes\r\nImageData.prototype.getPixelHash = function (rect) {\r\n    if (!rect) {\r\n        rect = new a1lib.Rect(0, 0, this.width, this.height);\r\n    }\r\n    var hash = 0;\r\n    for (var x = rect.x; x < rect.x + rect.width; x++) {\r\n        for (var y = rect.y; y < rect.y + rect.height; y++) {\r\n            var i = x * 4 + y * 4 * this.width;\r\n            hash = (((hash << 5) - hash) + this.data[i]) | 0;\r\n            hash = (((hash << 5) - hash) + this.data[i + 1]) | 0;\r\n            hash = (((hash << 5) - hash) + this.data[i + 2]) | 0;\r\n            hash = (((hash << 5) - hash) + this.data[i + 3]) | 0;\r\n        }\r\n    }\r\n    return hash;\r\n};\r\nImageData.prototype.clone = function (rect) {\r\n    return this.toImage(rect).getContext(\"2d\").getImageData(0, 0, rect.width, rect.height);\r\n};\r\nImageData.prototype.show = function (x = 5, y = 5, zoom = 1) {\r\n    if (typeof document == \"undefined\") {\r\n        console.error(\"need a document to show an imagedata object\");\r\n        return;\r\n    }\r\n    var imgs = document.getElementsByClassName(\"debugimage\");\r\n    while (imgs.length > ImageData.prototype.show.maxImages) {\r\n        imgs[0].remove();\r\n    }\r\n    var el = this.toImage();\r\n    el.classList.add(\"debugimage\");\r\n    el.style.position = \"absolute\";\r\n    el.style.zIndex = \"1000\";\r\n    el.style.left = x / zoom + \"px\";\r\n    el.style.top = y / zoom + \"px\";\r\n    el.style.background = \"purple\";\r\n    el.style.cursor = \"pointer\";\r\n    el.style.imageRendering = \"pixelated\";\r\n    el.style.outline = \"1px solid #0f0\";\r\n    el.style.width = (this.width == 1 ? 100 : this.width) * zoom + \"px\";\r\n    el.style.height = (this.height == 1 ? 100 : this.height) * zoom + \"px\";\r\n    el.onclick = function () { el.remove(); };\r\n    document.body.appendChild(el);\r\n    return el;\r\n};\r\nImageData.prototype.show.maxImages = 10;\r\nImageData.prototype.toImage = function (rect) {\r\n    if (!rect) {\r\n        rect = new a1lib.Rect(0, 0, this.width, this.height);\r\n    }\r\n    if (typeof document != \"undefined\") {\r\n        var el = document.createElement(\"canvas\");\r\n        el.width = rect.width;\r\n        el.height = rect.height;\r\n    }\r\n    else {\r\n        el = nodeimports.createCanvas(rect.width, rect.height);\r\n    }\r\n    var ctx = el.getContext(\"2d\");\r\n    ctx.putImageData(this.toDrawableData(), -rect.x, -rect.y);\r\n    return el;\r\n};\r\nImageData.prototype.getPixel = function (x, y) {\r\n    var i = x * 4 + y * 4 * this.width;\r\n    return [this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]];\r\n};\r\nImageData.prototype.getPixelValueSum = function (x, y) {\r\n    var i = x * 4 + y * 4 * this.width;\r\n    return this.data[i] + this.data[i + 1] + this.data[i + 2];\r\n};\r\nImageData.prototype.getPixelInt = function (x, y) {\r\n    var i = x * 4 + y * 4 * this.width;\r\n    return (this.data[i + 3] << 24) + (this.data[i + 0] << 16) + (this.data[i + 1] << 8) + (this.data[i + 2] << 0);\r\n};\r\nImageData.prototype.getColorDifference = function (x, y, r, g, b, a = 255) {\r\n    var i = x * 4 + y * 4 * this.width;\r\n    return Math.abs(this.data[i] - r) + Math.abs(this.data[i + 1] - g) + Math.abs(this.data[i + 2] - b) * a / 255;\r\n};\r\nImageData.prototype.setPixel = function (x, y, ...color) {\r\n    var r, g, b, a;\r\n    var [r, g, b, a] = (Array.isArray(color[0]) ? color[0] : color);\r\n    var i = x * 4 + y * 4 * this.width;\r\n    this.data[i] = r;\r\n    this.data[i + 1] = g;\r\n    this.data[i + 2] = b;\r\n    this.data[i + 3] = a == undefined ? 255 : a;\r\n};\r\nImageData.prototype.setPixelInt = function (x, y, color) {\r\n    var i = x * 4 + y * 4 * this.width;\r\n    this.data[i] = (color >> 24) & 0xff;\r\n    this.data[i + 1] = (color >> 16) & 0xff;\r\n    this.data[i + 2] = (color >> 8) & 0xff;\r\n    this.data[i + 3] = (color >> 0) & 0xff;\r\n};\r\nImageData.prototype.toFileBytes = function (format, quality) {\r\n    if (typeof HTMLCanvasElement != \"undefined\") {\r\n        return new Promise(d => this.toImage().toBlob(b => {\r\n            var r = new FileReader();\r\n            r.readAsArrayBuffer(b);\r\n            r.onload = () => d(new Uint8Array(r.result));\r\n        }, format, quality));\r\n    }\r\n    else {\r\n        return nodeimports.imageDataToFileBytes(this, format, quality);\r\n    }\r\n};\r\nImageData.prototype.toPngBase64 = function () {\r\n    if (typeof HTMLCanvasElement != \"undefined\") {\r\n        var str = this.toImage().toDataURL(\"image/png\");\r\n        return str.slice(str.indexOf(\",\") + 1);\r\n    }\r\n    else {\r\n        throw new Error(\"synchronous image conversion not supported in nodejs, try using ImageData.prototype.toFileBytes\");\r\n    }\r\n};\r\nImageData.prototype.pixelCompare = function (buf, x = 0, y = 0, max) {\r\n    return a1lib.ImageDetect.simpleCompare(this, buf, x, y, max);\r\n};\r\nImageData.prototype.copyTo = function (target, sourcex, sourcey, width, height, targetx, targety) {\r\n    //convince v8 that these are 31bit uints\r\n    const targetwidth = target.width | 0;\r\n    const thiswidth = this.width | 0;\r\n    const copywidth = width | 0;\r\n    const fastwidth = Math.floor(width / 4) * 4;\r\n    const thisdata = new Int32Array(this.data.buffer, this.data.byteOffset, this.data.byteLength / 4);\r\n    const targetdata = new Int32Array(target.data.buffer, target.data.byteOffset, target.data.byteLength / 4);\r\n    for (let cy = 0; cy < height; cy++) {\r\n        let cx = 0;\r\n        let it = (cx + targetx) + (cy + targety) * targetwidth;\r\n        let is = (cx + sourcex) + (cy + sourcey) * thiswidth;\r\n        //copy 4 pixels per iter (xmm)\r\n        for (; cx < fastwidth; cx += 4) {\r\n            targetdata[it] = thisdata[is];\r\n            targetdata[it + 1] = thisdata[is + 1];\r\n            targetdata[it + 2] = thisdata[is + 2];\r\n            targetdata[it + 3] = thisdata[is + 3];\r\n            it += 4;\r\n            is += 4;\r\n        }\r\n        //copy remainder per pixel\r\n        for (; cx < copywidth; cx++) {\r\n            targetdata[it] = thisdata[is];\r\n            it += 1;\r\n            is += 1;\r\n        }\r\n    }\r\n};\r\nif (typeof HTMLImageElement != \"undefined\") {\r\n    HTMLImageElement.prototype.toBuffer = function (x = 0, y = 0, w = this.width, h = this.height) {\r\n        var cnv = document.createElement(\"canvas\");\r\n        cnv.width = w;\r\n        cnv.height = h;\r\n        var ctx = cnv.getContext(\"2d\");\r\n        ctx.drawImage(this, -x, -y);\r\n        return ctx.getImageData(0, 0, w, h);\r\n    };\r\n    HTMLImageElement.prototype.toCanvas = function (x = 0, y = 0, w = this.width, h = this.height) {\r\n        var cnv = document.createElement(\"canvas\");\r\n        cnv.width = w;\r\n        cnv.height = h;\r\n        var ctx = cnv.getContext(\"2d\");\r\n        ctx.drawImage(this, -x, -y);\r\n        return cnv;\r\n    };\r\n}\r\n","//util class for rectangle maths\r\n//TODO shit this sucks can we remove it again?\r\n//more of a shorthand to get {x,y,width,height} than a class\r\n//kinda starting to like it again\r\n//TODO remove rant\r\n;\r\n/**\r\n * Simple rectangle class with some util functions\r\n */\r\nexport default class Rect {\r\n    constructor(x, y, w, h) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = w;\r\n        this.height = h;\r\n    }\r\n    static fromArgs(...args) {\r\n        if (typeof args[0] == \"object\") {\r\n            return new Rect(args[0].x, args[0].y, args[0].width, args[0].height);\r\n        }\r\n        else if (typeof args[0] == \"number\" && args.length >= 4) {\r\n            return new Rect(args[0], args[1], args[2], args[3]);\r\n        }\r\n        else {\r\n            throw new Error(\"invalid rect args\");\r\n        }\r\n    }\r\n    /**\r\n     * Resizes this Rect to include the full size of a given second rectangle\r\n     */\r\n    union(r2) {\r\n        var x = Math.min(this.x, r2.x);\r\n        var y = Math.min(this.y, r2.y);\r\n        this.width = Math.max(this.x + this.width, r2.x + r2.width) - x;\r\n        this.height = Math.max(this.y + this.height, r2.y + r2.height) - y;\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n    /**\r\n     * Resizes this Rect to include a given point\r\n     */\r\n    includePoint(x, y) {\r\n        this.union(new Rect(x, y, 0, 0));\r\n    }\r\n    /**\r\n     * Grows the rectangle with the given dimensions\r\n     */\r\n    inflate(w, h) {\r\n        this.x -= w;\r\n        this.y -= h;\r\n        this.width += 2 * w;\r\n        this.height += 2 * h;\r\n    }\r\n    /**\r\n     * Resizes this Rect to the area that overlaps a given Rect\r\n     * width and height will be set to 0 if the intersection does not exist\r\n     */\r\n    intersect(r2) {\r\n        if (this.x < r2.x) {\r\n            this.width -= r2.x - this.x;\r\n            this.x = r2.x;\r\n        }\r\n        if (this.y < r2.y) {\r\n            this.height -= r2.y - this.y;\r\n            this.y = r2.y;\r\n        }\r\n        this.width = Math.min(this.x + this.width, r2.x + r2.width) - this.x;\r\n        this.height = Math.min(this.y + this.height, r2.y + r2.height) - this.y;\r\n        if (this.width <= 0 || this.height <= 0) {\r\n            this.width = 0;\r\n            this.height = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Returns wether this Rect has at least one pixel overlap with a given Rect\r\n     */\r\n    overlaps(r2) {\r\n        return this.x < r2.x + r2.width && this.x + this.width > r2.x && this.y < r2.y + r2.height && this.y + this.height > r2.y;\r\n    }\r\n    /**\r\n     * Returns wether a given Rect fits completely inside this Rect\r\n     * @param r2\r\n     */\r\n    contains(r2) {\r\n        return this.x <= r2.x && this.x + this.width >= r2.x + r2.width && this.y <= r2.y && this.y + this.height >= r2.y + r2.height;\r\n    }\r\n    /**\r\n     * Returns wether a given point lies inside this Rect\r\n     */\r\n    containsPoint(x, y) {\r\n        return this.x <= x && this.x + this.width > x && this.y <= y && this.y + this.height > y;\r\n    }\r\n}\r\n","import { ImageData, Rect } from \"@alt1/base\";\r\nexport var debug = {\r\n    printcharscores: false,\r\n    trackread: false\r\n};\r\nexport var debugout = {};\r\n/**\r\n * draws the font definition to a buffer and displays it in the dom for debugging purposes\r\n * @param font\r\n */\r\nexport function debugFont(font) {\r\n    var spacing = font.width + 2;\r\n    var buf = new ImageData(spacing * font.chars.length, font.height + 1);\r\n    for (var a = 0; a < buf.data.length; a += 4) {\r\n        buf.data[a] = buf.data[a + 1] = buf.data[a + 2] = 0;\r\n        buf.data[a + 3] = 255;\r\n    }\r\n    for (var a = 0; a < font.chars.length; a++) {\r\n        var bx = a * spacing;\r\n        var chr = font.chars[a];\r\n        for (var b = 0; b < chr.pixels.length; b += (font.shadow ? 4 : 3)) {\r\n            buf.setPixel(bx + chr.pixels[b], chr.pixels[b + 1], [chr.pixels[b + 2], chr.pixels[b + 2], chr.pixels[b + 2], 255]);\r\n            if (font.shadow) {\r\n                buf.setPixel(bx + chr.pixels[b], chr.pixels[b + 1], [chr.pixels[b + 3], 0, 0, 255]);\r\n            }\r\n        }\r\n    }\r\n    buf.show();\r\n}\r\nexport function unblendBlackBackground(img, r, g, b) {\r\n    var rimg = new ImageData(img.width, img.height);\r\n    for (var i = 0; i < img.data.length; i += 4) {\r\n        var col = decomposeblack(img.data[i], img.data[i + 1], img.data[i + 2], r, g, b);\r\n        rimg.data[i + 0] = col[0] * 255;\r\n        rimg.data[i + 1] = rimg.data[i + 0];\r\n        rimg.data[i + 2] = rimg.data[i + 0];\r\n        rimg.data[i + 3] = 255;\r\n    }\r\n    return rimg;\r\n}\r\n/**\r\n * unblends a imagebuffer into match strength with given color\r\n * the bgimg argument should contain a second image with pixel occluded by the font visible.\r\n * @param img\r\n * @param shadow detect black as second color\r\n * @param bgimg optional second image to\r\n */\r\nexport function unblendKnownBg(img, bgimg, shadow, r, g, b) {\r\n    if (bgimg && (img.width != bgimg.width || img.height != bgimg.height)) {\r\n        throw \"bgimg size doesn't match\";\r\n    }\r\n    var rimg = new ImageData(img.width, img.height);\r\n    var totalerror = 0;\r\n    for (var i = 0; i < img.data.length; i += 4) {\r\n        var col = decompose2col(img.data[i], img.data[i + 1], img.data[i + 2], r, g, b, bgimg.data[i + 0], bgimg.data[i + 1], bgimg.data[i + 2]);\r\n        if (shadow) {\r\n            if (col[2] > 0.01) {\r\n                console.log(\"high error component: \" + (col[2] * 100).toFixed(1) + \"%\");\r\n            }\r\n            totalerror += col[2];\r\n            var m = 1 - col[1] - Math.abs(col[2]); //main color+black=100%-bg-error\r\n            rimg.data[i + 0] = m * 255;\r\n            rimg.data[i + 1] = col[0] / m * 255;\r\n            rimg.data[i + 2] = rimg.data[i + 0];\r\n        }\r\n        else {\r\n            rimg.data[i + 0] = col[0] * 255;\r\n            rimg.data[i + 1] = rimg.data[i + 0];\r\n            rimg.data[i + 2] = rimg.data[i + 0];\r\n        }\r\n        rimg.data[i + 3] = 255;\r\n    }\r\n    return rimg;\r\n}\r\n/**\r\n * Unblends a font image that is already conpletely isolated to the raw image used ingame. This is the easiest mode for pixel fonts where alpha is 0 or 255, or for extracted font files.\r\n * @param img\r\n * @param r\r\n * @param g\r\n * @param b\r\n * @param shadow whether the font has a black shadow\r\n */\r\nexport function unblendTrans(img, shadow, r, g, b) {\r\n    var rimg = new ImageData(img.width, img.height);\r\n    var pxlum = r + g + b;\r\n    for (var i = 0; i < img.data.length; i += 4) {\r\n        if (shadow) {\r\n            var lum = img.data[i + 0] + img.data[i + 1] + img.data[i + 2];\r\n            rimg.data[i + 0] = img.data[i + 3];\r\n            rimg.data[i + 1] = lum / pxlum * 255;\r\n            rimg.data[i + 2] = rimg.data[i + 0];\r\n        }\r\n        else {\r\n            rimg.data[i + 0] = img.data[i + 3];\r\n            rimg.data[i + 1] = rimg.data[i + 0];\r\n            rimg.data[i + 2] = rimg.data[i + 0];\r\n        }\r\n        rimg.data[i + 3] = 255;\r\n    }\r\n    return rimg;\r\n}\r\n/**\r\n * Determised wether color [rgb]m can be a result of a blend with color [rgb]1 that is p (0-1) of the mix\r\n * It returns the number that the second color has to lie outside of the possible color ranges\r\n * @param rm resulting color\r\n * @param r1 first color of the mix (the other color is unknown)\r\n * @param p the portion of the [rgb]1 in the mix (0-1)\r\n */\r\nexport function canblend(rm, gm, bm, r1, g1, b1, p) {\r\n    var m = Math.min(50, p / (1 - p));\r\n    var r = rm + (rm - r1) * m;\r\n    var g = gm + (gm - g1) * m;\r\n    var b = bm + (bm - b1) * m;\r\n    return Math.max(0, -r, -g, -b, r - 255, g - 255, b - 255);\r\n}\r\n/**\r\n * decomposes a color in 2 given component colors and returns the amount of each color present\r\n * also return a third (noise) component which is the the amount leftover orthagonal from the 2 given colors\r\n */\r\nexport function decompose2col(rp, gp, bp, r1, g1, b1, r2, g2, b2) {\r\n    //get the normal of the error (cross-product of both colors)\r\n    var r3 = g1 * b2 - g2 * b1;\r\n    var g3 = b1 * r2 - b2 * r1;\r\n    var b3 = r1 * g2 - r2 * g1;\r\n    //normalize to length 255\r\n    var norm = 255 / Math.sqrt(r3 * r3 + g3 * g3 + b3 * b3);\r\n    r3 *= norm;\r\n    g3 *= norm;\r\n    b3 *= norm;\r\n    return decompose3col(rp, gp, bp, r1, g1, b1, r2, g2, b2, r3, g3, b3);\r\n}\r\n/**\r\n * decomposes a pixel in a given color component and black and returns what proportion of the second color it contains\r\n * this is not as formal as decompose 2/3 and only give a \"good enough\" number\r\n */\r\nexport function decomposeblack(rp, gp, bp, r1, g1, b1) {\r\n    var dr = Math.abs(rp - r1);\r\n    var dg = Math.abs(gp - g1);\r\n    var db = Math.abs(bp - b1);\r\n    var maxdif = Math.max(dr, dg, db);\r\n    return [1 - maxdif / 255];\r\n}\r\n/**\r\n * decomposes a color in 3 given component colors and returns the amount of each color present\r\n */\r\nexport function decompose3col(rp, gp, bp, r1, g1, b1, r2, g2, b2, r3, g3, b3) {\r\n    //P=x*C1+y*C2+z*C3\r\n    //assemble as matrix \r\n    //M*w=p\r\n    //get inverse of M\r\n    //dirty written out version of cramer's rule\r\n    var A = g2 * b3 - b2 * g3;\r\n    var B = g3 * b1 - b3 * g1;\r\n    var C = g1 * b2 - b1 * g2;\r\n    var D = b2 * r3 - r2 * b3;\r\n    var E = b3 * r1 - r3 * b1;\r\n    var F = b1 * r2 - r1 * b2;\r\n    var G = r2 * g3 - g2 * r3;\r\n    var H = r3 * g1 - g3 * r1;\r\n    var I = r1 * g2 - g1 * r2;\r\n    var det = r1 * A + g1 * D + b1 * G;\r\n    //M^-1*p=w\r\n    var x = (A * rp + D * gp + G * bp) / det;\r\n    var y = (B * rp + E * gp + H * bp) / det;\r\n    var z = (C * rp + F * gp + I * bp) / det;\r\n    return [x, y, z];\r\n}\r\n/**\r\n * brute force to the exact position of the text\r\n */\r\nexport function findChar(buffer, font, col, x, y, w, h) {\r\n    if (x < 0) {\r\n        return null;\r\n    }\r\n    if (y - font.basey < 0) {\r\n        return null;\r\n    }\r\n    if (x + w + font.width > buffer.width) {\r\n        return null;\r\n    }\r\n    if (y + h - font.basey + font.height > buffer.height) {\r\n        return null;\r\n    }\r\n    var best = 1000; //TODO finetune score constants\r\n    var bestchar = null;\r\n    for (var cx = x; cx < x + w; cx++) {\r\n        for (var cy = y; cy < y + h; cy++) {\r\n            var chr = readChar(buffer, font, col, cx, cy, false, false);\r\n            if (chr != null && chr.sizescore < best) {\r\n                best = chr.sizescore;\r\n                bestchar = chr;\r\n            }\r\n        }\r\n    }\r\n    return bestchar;\r\n}\r\n/**\r\n * reads text with unknown exact coord or color. The given coord should be inside the text\r\n * color selection not implemented yet\r\n */\r\nexport function findReadLine(buffer, font, cols, x, y, w = -1, h = -1) {\r\n    if (w == -1) {\r\n        w = font.width + font.spacewidth;\r\n        x -= Math.ceil(w / 2);\r\n    }\r\n    if (h == -1) {\r\n        h = 7;\r\n        y -= 1;\r\n    }\r\n    var chr = null;\r\n    if (cols.length > 1) {\r\n        //TODO use getChatColor() instead for non-mono?\r\n        var sorted = GetChatColorMono(buffer, new Rect(x, y - font.basey, w, h), cols);\r\n        //loop until we have a match (max 2 cols)\r\n        for (var a = 0; a < 2 && a < sorted.length && chr == null; a++) {\r\n            chr = findChar(buffer, font, sorted[a].col, x, y, w, h);\r\n        }\r\n    }\r\n    else {\r\n        chr = findChar(buffer, font, cols[0], x, y, w, h);\r\n    }\r\n    if (chr == null) {\r\n        return { debugArea: { x, y, w, h }, text: \"\", fragments: [] };\r\n    }\r\n    return readLine(buffer, font, cols, chr.x, chr.y, true, true);\r\n}\r\nexport function GetChatColorMono(buf, rect, colors) {\r\n    var colormap = colors.map(c => ({ col: c, score: 0 }));\r\n    if (rect.x < 0 || rect.y < 0 || rect.x + rect.width > buf.width || rect.y + rect.height > buf.height) {\r\n        return colormap;\r\n    }\r\n    var data = buf.data;\r\n    var maxd = 50;\r\n    for (var colobj of colormap) {\r\n        var score = 0;\r\n        var col = colobj.col;\r\n        for (var y = rect.y; y < rect.y + rect.height; y++) {\r\n            for (var x = rect.x; x < rect.x + rect.width; x++) {\r\n                var i = x * 4 + y * 4 * buf.width;\r\n                var d = Math.abs(data[i] - col[0]) + Math.abs(data[i + 1] - col[1]) + Math.abs(data[i + 2] - col[2]);\r\n                if (d < maxd) {\r\n                    score += maxd - d;\r\n                }\r\n            }\r\n        }\r\n        colobj.score = score;\r\n    }\r\n    return colormap.sort((a, b) => b.score - a.score);\r\n}\r\nfunction unblend(r, g, b, R, G, B) {\r\n    var m = Math.sqrt(r * r + g * g + b * b);\r\n    var n = Math.sqrt(R * R + G * G + B * B);\r\n    var x = (r * R + g * G + b * B) / n;\r\n    var y = Math.sqrt(Math.max(0, m * m - x * x));\r\n    var r1 = Math.max(0, (63.75 - y) * 4);\r\n    var r2 = x / n * 255;\r\n    if (r2 > 255) //brighter than refcol\r\n     {\r\n        r1 = Math.max(0, r1 - r2 + 255);\r\n        r2 = 255;\r\n    }\r\n    return [r1, r2];\r\n}\r\nexport function getChatColor(buf, rect, colors) {\r\n    var bestscore = -1.0;\r\n    var best = null;\r\n    var b2 = 0.0;\r\n    var data = buf.data;\r\n    for (let col of colors) {\r\n        var score = 0.0;\r\n        for (var y = rect.y; y < rect.y + rect.height; y++) {\r\n            for (var x = rect.x; x < rect.x + rect.width; x++) {\r\n                if (x < 0 || x + 1 >= buf.width) {\r\n                    continue;\r\n                }\r\n                if (y < 0 || y + 1 >= buf.width) {\r\n                    continue;\r\n                }\r\n                let i1 = buf.pixelOffset(x, y);\r\n                let i2 = buf.pixelOffset(x + 1, y + 1);\r\n                var pixel1 = unblend(data[i1 + 0], data[i1 + 1], data[i1 + 2], col[0], col[1], col[2]);\r\n                var pixel2 = unblend(data[i2 + 0], data[i2 + 1], data[i2 + 2], col[0], col[1], col[2]);\r\n                //TODO this is from c# can simplify a bit\r\n                var s = (pixel1[0] / 255 * pixel1[1] / 255) * (pixel2[0] / 255 * (255.0 - pixel2[1]) / 255);\r\n                score += s;\r\n            }\r\n        }\r\n        if (score > bestscore) {\r\n            b2 = bestscore;\r\n            bestscore = score;\r\n            best = col;\r\n        }\r\n        else if (score > b2) {\r\n            b2 = score;\r\n        }\r\n    }\r\n    //Console.WriteLine(\"color: \" + bestcol + \" - \" + (bestscore - b2));\r\n    //bestscore /= rect.width * rect.height;\r\n    return best;\r\n}\r\n/**\r\n * reads a line of text with exactly known position and color. y should be the y coord of the text base line, x should be the first pixel of a new character\r\n */\r\nexport function readLine(buffer, font, colors, x, y, forward, backward = false) {\r\n    if (typeof colors[0] != \"number\" && colors.length == 1) {\r\n        colors = colors[0];\r\n    }\r\n    var multicol = typeof colors[0] != \"number\";\r\n    var allcolors = multicol ? colors : [colors];\r\n    var detectcolor = function (sx, sy, backward) {\r\n        var w = Math.floor(font.width * 1.5);\r\n        if (backward) {\r\n            sx -= w;\r\n        }\r\n        sy -= font.basey;\r\n        return getChatColor(buffer, { x: sx, y: sy, width: w, height: font.height }, allcolors);\r\n    };\r\n    var fragments = [];\r\n    var x1 = x;\r\n    var x2 = x;\r\n    var maxspaces = (typeof font.maxspaces == \"number\" ? font.maxspaces : 1);\r\n    let fragtext = \"\";\r\n    let fraghadprimary = false;\r\n    var lastcol = null;\r\n    let addfrag = (forward) => {\r\n        if (!fragtext) {\r\n            return;\r\n        }\r\n        let frag = {\r\n            text: fragtext,\r\n            color: lastcol,\r\n            index: 0,\r\n            xstart: x + (forward ? fragstartdx : fragenddx),\r\n            xend: x + (forward ? fragenddx : fragstartdx)\r\n        };\r\n        if (forward) {\r\n            fragments.push(frag);\r\n        }\r\n        else {\r\n            fragments.unshift(frag);\r\n        }\r\n        fragtext = \"\";\r\n        fragstartdx = dx;\r\n        fraghadprimary = false;\r\n    };\r\n    for (var dirforward of [true, false]) {\r\n        //init vars\r\n        if (dirforward && !forward) {\r\n            continue;\r\n        }\r\n        if (!dirforward && !backward) {\r\n            continue;\r\n        }\r\n        var dx = 0;\r\n        var fragstartdx = dx;\r\n        var fragenddx = dx;\r\n        var triedspaces = 0;\r\n        var triedrecol = false;\r\n        var col = multicol ? null : colors;\r\n        while (true) {\r\n            col = col || detectcolor(x + dx, y, !dirforward);\r\n            var chr = (col ? readChar(buffer, font, col, x + dx, y, !dirforward, true) : null);\r\n            if (col == null || chr == null) {\r\n                if (triedspaces < maxspaces) {\r\n                    dx += (dirforward ? 1 : -1) * font.spacewidth;\r\n                    triedspaces++;\r\n                    continue;\r\n                }\r\n                if (multicol && !triedrecol && fraghadprimary) {\r\n                    dx -= (dirforward ? 1 : -1) * triedspaces * font.spacewidth;\r\n                    triedspaces = 0;\r\n                    col = null;\r\n                    triedrecol = true;\r\n                    continue;\r\n                }\r\n                if (dirforward) {\r\n                    x2 = x + dx - font.spacewidth;\r\n                }\r\n                else {\r\n                    x1 = x + dx + font.spacewidth;\r\n                }\r\n                break;\r\n            }\r\n            else {\r\n                if (lastcol && (col[0] != lastcol[0] || col[1] != lastcol[1] || col[2] != lastcol[2])) {\r\n                    addfrag(dirforward);\r\n                }\r\n                var spaces = \"\";\r\n                for (var a = 0; a < triedspaces; a++) {\r\n                    spaces += \" \";\r\n                }\r\n                if (dirforward) {\r\n                    fragtext += spaces + chr.chr;\r\n                }\r\n                else {\r\n                    fragtext = chr.chr + spaces + fragtext;\r\n                }\r\n                if (!chr.basechar.secondary) {\r\n                    fraghadprimary = true;\r\n                }\r\n                triedspaces = 0;\r\n                triedrecol = false;\r\n                dx += (dirforward ? 1 : -1) * chr.basechar.width;\r\n                fragenddx = dx;\r\n                lastcol = col;\r\n            }\r\n        }\r\n        if (lastcol && fraghadprimary) {\r\n            addfrag(dirforward);\r\n        }\r\n    }\r\n    fragments.forEach((f, i) => f.index = i);\r\n    return {\r\n        debugArea: { x: x1, y: y - 9, w: x2 - x1, h: 10 },\r\n        text: fragments.map(f => f.text).join(\"\"),\r\n        fragments\r\n    };\r\n}\r\n/**\r\n * Reads a line of text that uses a smallcaps font, these fonts can have duplicate chars that only have a different amount of\r\n * empty space after the char before the next char starts.\r\n * The coordinates should be near the end of the string, or a rectangle with high 1 containing all points where the string can end.\r\n */\r\nexport function readSmallCapsBackwards(buffer, font, cols, x, y, w = -1, h = -1) {\r\n    if (w == -1) {\r\n        w = font.width + font.spacewidth;\r\n        x -= Math.ceil(w / 2);\r\n    }\r\n    if (h == -1) {\r\n        h = 7;\r\n        y -= 1;\r\n    }\r\n    var matchedchar = null;\r\n    var sorted = (cols.length == 1 ? [{ col: cols[0], score: 1 }] : GetChatColorMono(buffer, new Rect(x, y - font.basey, w, h), cols));\r\n    //loop until we have a match (max 2 cols)\r\n    for (var a = 0; a < 2 && a < sorted.length && matchedchar == null; a++) {\r\n        for (var cx = x + w - 1; cx >= x; cx--) {\r\n            var best = 1000; //TODO finetune score constants\r\n            var bestchar = null;\r\n            for (var cy = y; cy < y + h; cy++) {\r\n                var chr = readChar(buffer, font, sorted[a].col, cx, cy, true, false);\r\n                if (chr != null && chr.sizescore < best) {\r\n                    best = chr.sizescore;\r\n                    bestchar = chr;\r\n                }\r\n            }\r\n            if (bestchar) {\r\n                matchedchar = bestchar;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (matchedchar == null) {\r\n        return { text: \"\", debugArea: { x, y, w, h } };\r\n    }\r\n    return readLine(buffer, font, cols, matchedchar.x, matchedchar.y, false, true);\r\n}\r\n/**\r\n * Reads a single character at the exact given location\r\n * @param x exact x location of the start of the character domain (includes part of the spacing between characters)\r\n * @param y exact y location of the baseline pixel of the character\r\n * @param backwards read in backwards direction, the x location should be the first pixel after the character domain in that case\r\n */\r\nexport function readChar(buffer, font, col, x, y, backwards, allowSecondary) {\r\n    y -= font.basey;\r\n    var shiftx = 0;\r\n    var shifty = font.basey;\r\n    var shadow = font.shadow;\r\n    var debugobj = null;\r\n    var debugimg = null;\r\n    if (debug.trackread) {\r\n        var name = x + \";\" + y + \" \" + JSON.stringify(col);\r\n        if (!debugout[name]) {\r\n            debugout[name] = [];\r\n        }\r\n        debugobj = debugout[name];\r\n    }\r\n    //===== make sure the full domain is inside the bitmap/buffer ======\r\n    if (y < 0 || y + font.height >= buffer.height) {\r\n        return null;\r\n    }\r\n    if (!backwards) {\r\n        if (x < 0 || x + font.width > buffer.width) {\r\n            return null;\r\n        }\r\n    }\r\n    else {\r\n        if (x - font.width < 0 || x > buffer.width) {\r\n            return null;\r\n        }\r\n    }\r\n    //====== start reading the char ======\r\n    var scores = [];\r\n    for (var chr = 0; chr < font.chars.length; chr++) {\r\n        var chrobj = font.chars[chr];\r\n        if (chrobj.secondary && !allowSecondary) {\r\n            continue;\r\n        }\r\n        scores[chr] = { score: 0, sizescore: 0, chr: chrobj };\r\n        var chrx = (backwards ? x - chrobj.width : x);\r\n        if (debug.trackread) {\r\n            debugimg = new ImageData(font.width, font.height);\r\n        }\r\n        for (var a = 0; a < chrobj.pixels.length;) {\r\n            var i = (chrx + chrobj.pixels[a]) * 4 + (y + chrobj.pixels[a + 1]) * buffer.width * 4;\r\n            var penalty = 0;\r\n            if (!shadow) {\r\n                penalty = canblend(buffer.data[i], buffer.data[i + 1], buffer.data[i + 2], col[0], col[1], col[2], chrobj.pixels[a + 2] / 255);\r\n                a += 3;\r\n            }\r\n            else {\r\n                var lum = chrobj.pixels[a + 3] / 255;\r\n                penalty = canblend(buffer.data[i], buffer.data[i + 1], buffer.data[i + 2], col[0] * lum, col[1] * lum, col[2] * lum, chrobj.pixels[a + 2] / 255);\r\n                a += 4;\r\n            }\r\n            scores[chr].score += Math.max(0, penalty);\r\n            //TODO add compiler flag to this to remove it for performance\r\n            if (debugimg) {\r\n                debugimg.setPixel(chrobj.pixels[a], chrobj.pixels[a + 1], [penalty, penalty, penalty, 255]);\r\n            }\r\n        }\r\n        scores[chr].sizescore = scores[chr].score - chrobj.bonus;\r\n        if (debugobj) {\r\n            debugobj.push({ chr: chrobj.chr, score: scores[chr].sizescore, rawscore: scores[chr].score, img: debugimg });\r\n        }\r\n    }\r\n    scores.sort((a, b) => a.sizescore - b.sizescore);\r\n    if (debug.printcharscores) {\r\n        scores.slice(0, 5).forEach(q => console.log(q.chr.chr, q.score.toFixed(3), q.sizescore.toFixed(3)));\r\n    }\r\n    var winchr = scores[0];\r\n    if (!winchr || winchr.score > 400) {\r\n        return null;\r\n    }\r\n    return { chr: winchr.chr.chr, basechar: winchr.chr, x: x + shiftx, y: y + shifty, score: winchr.score, sizescore: winchr.sizescore };\r\n}\r\n/**\r\n * Generates a font json description to use in reader functions\r\n * @param unblended A source image with all characters lined up. The image should be unblended into components using the unblend functions\r\n * The lowest pixel line of this image is used to mark the location and size of the charecters if the red component is 255 it means there is a character on that pixel column\r\n * @param chars A string containing all the characters of the image in the same order\r\n * @param seconds A string with characters that are considered unlikely and should only be detected if no other character is possible.\r\n * For example the period (.) character matches positive inside many other characters and should be marked as secondary\r\n * @param bonusses An object that contains bonus scores for certain difficult characters to make the more likely to be red.\r\n * @param basey The y position of the baseline pixel of the font\r\n * @param spacewidth the number of pixels a space takes\r\n * @param treshold minimal color match proportion (0-1) before a pixel is used for the font\r\n * @param shadow whether this font also uses the black shadow some fonts have. The \"unblended\" image should be unblended correspondingly\r\n * @returns a javascript object describing the font which is used as input for the different read functions\r\n */\r\nexport function generatefont(unblended, chars, seconds, bonusses, basey, spacewidth, treshold, shadow) {\r\n    //settings vars\r\n    treshold *= 255;\r\n    //initial vars\r\n    var miny = unblended.height - 1;\r\n    var maxy = 0;\r\n    var font = { chars: [], width: 0, spacewidth: spacewidth, shadow: shadow, height: 0, basey: 0 };\r\n    var ds = false;\r\n    var chardata = [];\r\n    //index all chars\r\n    for (var dx = 0; dx < unblended.width; dx++) {\r\n        var i = 4 * dx + 4 * unblended.width * (unblended.height - 1);\r\n        if (unblended.data[i] == 255 && unblended.data[i + 3] == 255) {\r\n            if (ds === false) {\r\n                ds = dx;\r\n            }\r\n        }\r\n        else {\r\n            if (ds !== false) {\r\n                //char found, start detection\r\n                var de = dx;\r\n                var char = chars[chardata.length];\r\n                var chr = {\r\n                    ds: ds,\r\n                    de: de,\r\n                    width: de - ds,\r\n                    chr: char,\r\n                    bonus: (bonusses && bonusses[char]) || 0,\r\n                    secondary: seconds.indexOf(chars[chardata.length]) != -1,\r\n                    pixels: []\r\n                };\r\n                chardata.push(chr);\r\n                font.width = Math.max(font.width, chr.width);\r\n                for (x = 0; x < de - ds; x++) {\r\n                    for (y = 0; y < unblended.height - 1; y++) {\r\n                        var i = (x + ds) * 4 + y * unblended.width * 4;\r\n                        if (unblended.data[i] >= treshold) {\r\n                            miny = Math.min(miny, y);\r\n                            maxy = Math.max(maxy, y);\r\n                        }\r\n                    }\r\n                }\r\n                ds = false;\r\n            }\r\n        }\r\n    }\r\n    font.height = maxy + 1 - miny;\r\n    font.basey = basey - miny;\r\n    //detect all pixels\r\n    for (var a in chardata) {\r\n        var chr = chardata[a];\r\n        for (var x = 0; x < chr.width; x++) {\r\n            for (var y = 0; y < maxy + 1 - miny; y++) {\r\n                var i = (x + chr.ds) * 4 + (y + miny) * unblended.width * 4;\r\n                if (unblended.data[i] >= treshold) {\r\n                    chr.pixels.push(x, y);\r\n                    chr.pixels.push(unblended.data[i]);\r\n                    if (shadow) {\r\n                        chr.pixels.push(unblended.data[i + 1]);\r\n                    }\r\n                    chr.bonus += 5;\r\n                }\r\n            }\r\n        }\r\n        //prevent js from doing the thing with unnecessary output precision\r\n        chr.bonus = +chr.bonus.toFixed(3);\r\n        font.chars.push({ width: chr.width, bonus: chr.bonus, chr: chr.chr, pixels: chr.pixels, secondary: chr.secondary });\r\n    }\r\n    return font;\r\n}\r\n","import * as OCR from \"@alt1/ocr\";\r\n\r\nfunction cleanDigits(s: string): string {\r\n  return s.replace(/[^\\d]/g, \"\");\r\n}\r\n\r\nfunction readLineText(img: any): string | null {\r\n  try {\r\n    // readLine(img, x, y, w, h, font, [optional 7th arg])\r\n    // debugFont exists in @alt1/ocr and is safe to pass as the font.\r\n    const res = (OCR as any).readLine(img, 0, 0, img.width, img.height, (OCR as any).debugFont, null);\r\n    return res?.text ? String(res.text) : null;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport function readStackNumber(img: any): number | null {\r\n  const text = readLineText(img);\r\n  if (!text) return null;\r\n\r\n  const cleaned = cleanDigits(text);\r\n  if (!cleaned) return null;\r\n\r\n  const n = Number(cleaned);\r\n  return Number.isFinite(n) && n > 0 ? n : null;\r\n}\r\n\r\nexport function readMoneyGain(img: any): number | null {\r\n  const text = readLineText(img);\r\n  if (!text) return null;\r\n\r\n  if (!text.includes(\"+\")) return null;\r\n\r\n  const cleaned = cleanDigits(text);\r\n  if (!cleaned) return null;\r\n\r\n  const n = Number(cleaned);\r\n  return Number.isFinite(n) && n > 0 ? n : null;\r\n}","export function aHash64(img: ImageData): string {\r\n  const data = img.data;\r\n  let hash = 0;\r\n\r\n  for (let i = 0; i < data.length; i += 64) {\r\n    hash = (hash * 31 + data[i]) >>> 0;\r\n  }\r\n\r\n  return hash.toString(16);\r\n}","import { Rect } from \"./storage\";\r\n\r\n/**\r\n * Reads the last Alt1 captured region.\r\n *\r\n * In most Alt1 apps: user uses Alt1s capture tool and presses Alt+1,\r\n * then the app can read that region.\r\n *\r\n * If this doesnt work in your environment, this is the only file you should need to adapt.\r\n */\r\nexport async function getRegionFromAlt1(): Promise<Rect | null> {\r\n  const alt1Any = (window as any).alt1;\r\n  if (!alt1Any) return null;\r\n\r\n  // Common patterns seen in Alt1 apps:\r\n  // - alt1.getRegion() returns {x,y,w,h}\r\n  // - alt1.getRegion() returns null if nothing captured\r\n  if (typeof alt1Any.getRegion === \"function\") {\r\n    const r = alt1Any.getRegion();\r\n    if (r && typeof r.x === \"number\") {\r\n      return { x: r.x, y: r.y, w: r.w, h: r.h };\r\n    }\r\n  }\r\n\r\n  // Some builds store region differently; try a couple fallbacks.\r\n  if (alt1Any.lastRegion && typeof alt1Any.lastRegion.x === \"number\") {\r\n    const r = alt1Any.lastRegion;\r\n    return { x: r.x, y: r.y, w: r.w, h: r.h };\r\n  }\r\n\r\n  return null;\r\n}\r\n","export type Rect = { x: number; y: number; w: number; h: number };\r\n\r\nexport type LootEntry = {\r\n  key: string;\r\n  name: string;\r\n  qty: number;\r\n  iconSig: string | null; // only inventory items have a signature icon\r\n};\r\n\r\nexport type Session = {\r\n  id: string;\r\n  label: string;\r\n  startedAt: number;\r\n  endedAt: number | null;\r\n  loot: LootEntry[];\r\n};\r\n\r\nexport type AppState = {\r\n  settings: {\r\n    invRegion: Rect | null;\r\n    moneyRegion: Rect | null;\r\n  };\r\n  iconNames: Record<string, string>;\r\n  sessions: Session[];\r\n  activeSession: Session | null;\r\n};\r\n\r\nconst KEY = \"alt1_loot_tracker_state_v1\";\r\n\r\nexport function loadAppState(): AppState {\r\n  const raw = localStorage.getItem(KEY);\r\n  if (raw) {\r\n    try {\r\n      const parsed = JSON.parse(raw) as AppState;\r\n      // light migration defaults\r\n      return {\r\n        settings: {\r\n          invRegion: parsed.settings?.invRegion ?? null,\r\n          moneyRegion: parsed.settings?.moneyRegion ?? null\r\n        },\r\n        iconNames: parsed.iconNames ?? {},\r\n        sessions: parsed.sessions ?? [],\r\n        activeSession: null\r\n      };\r\n    } catch {\r\n      // fallthrough\r\n    }\r\n  }\r\n  return {\r\n    settings: { invRegion: null, moneyRegion: null },\r\n    iconNames: {},\r\n    sessions: [],\r\n    activeSession: null\r\n  };\r\n}\r\n\r\nexport function saveAppState(state: AppState) {\r\n  localStorage.setItem(KEY, JSON.stringify({\r\n    settings: state.settings,\r\n    iconNames: state.iconNames,\r\n    sessions: state.sessions\r\n  }));\r\n}\r\n","import { AppState, LootEntry, Session } from \"./storage\";\r\n\r\nexport function setText(id: string, text: string) {\r\n  const el = document.getElementById(id);\r\n  if (el) el.textContent = text;\r\n}\r\n\r\nexport function renderLootTable(entries: LootEntry[], state: AppState) {\r\n  const tbody = document.getElementById(\"lootRows\") as HTMLTableSectionElement;\r\n  tbody.innerHTML = \"\";\r\n\r\n  for (const e of entries) {\r\n    const tr = document.createElement(\"tr\");\r\n    tr.dataset.sig = e.iconSig ?? \"\";\r\n\r\n    const tdIcon = document.createElement(\"td\");\r\n    if (e.iconSig) {\r\n      const img = document.createElement(\"img\");\r\n      img.className = \"loot-icon\";\r\n      img.alt = e.name;\r\n      img.dataset.sig = e.iconSig;\r\n      // src is filled by wireClickRename() once we can ask tracker for data URLs\r\n      tdIcon.appendChild(img);\r\n    } else {\r\n      tdIcon.textContent = \"\";\r\n    }\r\n\r\n    const tdName = document.createElement(\"td\");\r\n    tdName.textContent = e.name;\r\n\r\n    const tdQty = document.createElement(\"td\");\r\n    tdQty.className = \"right\";\r\n    tdQty.textContent = e.qty.toLocaleString();\r\n\r\n    tr.appendChild(tdIcon);\r\n    tr.appendChild(tdName);\r\n    tr.appendChild(tdQty);\r\n    tbody.appendChild(tr);\r\n  }\r\n}\r\n\r\nexport function renderSessionTable(sessions: Session[]) {\r\n  const tbody = document.getElementById(\"sessionRows\") as HTMLTableSectionElement;\r\n  tbody.innerHTML = \"\";\r\n\r\n  for (const s of sessions.slice(0, 20)) {\r\n    const tr = document.createElement(\"tr\");\r\n\r\n    const tdWhen = document.createElement(\"td\");\r\n    tdWhen.textContent = new Date(s.startedAt).toLocaleString();\r\n\r\n    const tdLabel = document.createElement(\"td\");\r\n    tdLabel.textContent = s.label;\r\n\r\n    const tdCount = document.createElement(\"td\");\r\n    tdCount.className = \"right\";\r\n    tdCount.textContent = String(s.loot.length);\r\n\r\n    tr.appendChild(tdWhen);\r\n    tr.appendChild(tdLabel);\r\n    tr.appendChild(tdCount);\r\n    tbody.appendChild(tr);\r\n  }\r\n}\r\n\r\n/**\r\n * Allows clicking an inventory-based loot row to name it once.\r\n * Also fills in icon <img src> from tracker callback.\r\n */\r\nexport function wireClickRename(state: AppState, getIconUrl: (sig: string) => string | null) {\r\n  // Fill icons\r\n  document.querySelectorAll<HTMLImageElement>(\"img.loot-icon\").forEach((img) => {\r\n    const sig = img.dataset.sig;\r\n    if (!sig) return;\r\n    const url = getIconUrl(sig);\r\n    if (url) img.src = url;\r\n  });\r\n\r\n  // Click to rename\r\n  const tbody = document.getElementById(\"lootRows\");\r\n  if (!tbody) return;\r\n\r\n  tbody.onclick = (ev) => {\r\n    const tr = (ev.target as HTMLElement).closest(\"tr\");\r\n    if (!tr) return;\r\n    const sig = tr.dataset.sig;\r\n    if (!sig) return;\r\n\r\n    const existing = state.iconNames[sig] ?? \"\";\r\n    const name = prompt(\"Name this item (stored locally):\", existing);\r\n    if (!name) return;\r\n    state.iconNames[sig] = name.trim();\r\n  };\r\n}\r\n","import { LootTracker } from \"./lootTracker\";\r\nimport { loadAppState, saveAppState, AppState } from \"./storage\";\r\nimport { setText, renderLootTable, renderSessionTable, wireClickRename } from \"./ui\";\r\n\r\nconst state: AppState = loadAppState();\r\nconst tracker = new LootTracker(state);\r\n\r\nconst btnCalibInv = document.getElementById(\"btnCalibInv\") as HTMLButtonElement;\r\nconst btnCalibMoney = document.getElementById(\"btnCalibMoney\") as HTMLButtonElement;\r\nconst btnStart = document.getElementById(\"btnStart\") as HTMLButtonElement;\r\nconst btnPause = document.getElementById(\"btnPause\") as HTMLButtonElement;\r\nconst btnStop = document.getElementById(\"btnStop\") as HTMLButtonElement;\r\nconst btnClearAll = document.getElementById(\"btnClearAll\") as HTMLButtonElement;\r\n\r\nconst sessionLabel = document.getElementById(\"sessionLabel\") as HTMLInputElement;\r\n\r\nfunction refreshUI() {\r\n  setText(\"statusInv\", tracker.hasInventoryRegion() ? \"Inventory: set\" : \"Inventory: not set\");\r\n  setText(\"statusMoney\", tracker.hasMoneyRegion() ? \"Money: set\" : \"Money: not set\");\r\n  setText(\"statusRun\", `Status: ${tracker.getRunState()}`);\r\n\r\n  btnStart.disabled = tracker.getRunState() !== \"idle\";\r\n  btnPause.disabled = tracker.getRunState() === \"idle\";\r\n  btnStop.disabled = tracker.getRunState() === \"idle\";\r\n\r\n  renderLootTable(tracker.getCurrentLoot(), state);\r\n  renderSessionTable(state.sessions);\r\n  wireClickRename(state, (sig) => tracker.getIconPngDataUrl(sig));\r\n\r\n  saveAppState(state);\r\n}\r\n\r\nbtnCalibInv.onclick = async () => {\r\n  const ok = await tracker.calibrateInventoryRegion();\r\n  if (!ok) alert(\"Failed to read region. Use Alt1 region capture (Alt+1) on your inventory panel first.\");\r\n  refreshUI();\r\n};\r\n\r\nbtnCalibMoney.onclick = async () => {\r\n  const ok = await tracker.calibrateMoneyRegion();\r\n  if (!ok) alert(\"Failed to read region. Use Alt1 region capture (Alt+1) on the yellow +X gain text area.\");\r\n  refreshUI();\r\n};\r\n\r\nbtnStart.onclick = () => {\r\n  tracker.start(sessionLabel.value.trim() || \"Unnamed\");\r\n  refreshUI();\r\n};\r\n\r\nbtnPause.onclick = () => {\r\n  tracker.togglePause();\r\n  refreshUI();\r\n};\r\n\r\nbtnStop.onclick = () => {\r\n  tracker.stop();\r\n  refreshUI();\r\n};\r\n\r\nbtnClearAll.onclick = () => {\r\n  if (!confirm(\"Clear all saved sessions and icon names?\")) return;\r\n  state.sessions = [];\r\n  state.iconNames = {};\r\n  tracker.reset();\r\n  refreshUI();\r\n};\r\n\r\ntracker.onUpdate(refreshUI);\r\nrefreshUI();\r\n","import { captureHoldFullRs } from \"@alt1/base\";\r\nimport { readStackNumber, readMoneyGain } from \"./ocr\";\r\nimport { aHash64 } from \"./phash\";\r\nimport { AppState, LootEntry, Rect, Session } from \"./storage\";\r\nimport { getRegionFromAlt1 } from \"./alt1region\";\r\n\r\ntype RunState = \"idle\" | \"running\" | \"paused\";\r\n\r\ntype SlotSnap = {\r\n  sig: string | null;\r\n  qty: number | null;\r\n};\r\n\r\nexport class LootTracker {\r\n  private state: AppState;\r\n  private runState: RunState = \"idle\";\r\n  private invRegion: Rect | null;\r\n  private moneyRegion: Rect | null;\r\n\r\n  private slots: SlotSnap[] = Array.from({ length: 28 }, () => ({\r\n    sig: null,\r\n    qty: null\r\n  }));\r\n\r\n  private loot: Record<string, LootEntry> = {};\r\n  private iconCache: Record<string,string> = {};\r\n  private timer: number | null = null;\r\n  private updateCb: (() => void) | null = null;\r\n\r\n  constructor(state: AppState) {\r\n    this.state = state;\r\n    this.invRegion = state.settings.invRegion ?? null;\r\n    this.moneyRegion = state.settings.moneyRegion ?? null;\r\n  }\r\n\r\n  onUpdate(cb: () => void){ this.updateCb = cb; }\r\n\r\n  hasInventoryRegion(){ return !!this.invRegion; }\r\n  hasMoneyRegion(){ return !!this.moneyRegion; }\r\n  getRunState(){ return this.runState; }\r\n\r\n  getCurrentLoot(): LootEntry[] {\r\n    return Object.values(this.loot).sort((a,b)=>b.qty-a.qty);\r\n  }\r\n\r\n  getIconPngDataUrl(sig:string){\r\n    return this.iconCache[sig] ?? null;\r\n  }\r\n\r\n  reset(){\r\n    this.loot = {};\r\n    this.slots = this.slots.map(()=>({sig:null,qty:null}));\r\n  }\r\n\r\n  async calibrateInventoryRegion(){\r\n    const r = await getRegionFromAlt1();\r\n    if(!r) return false;\r\n    this.invRegion = r;\r\n    this.state.settings.invRegion = r;\r\n    return true;\r\n  }\r\n\r\n  async calibrateMoneyRegion(){\r\n    const r = await getRegionFromAlt1();\r\n    if(!r) return false;\r\n    this.moneyRegion = r;\r\n    this.state.settings.moneyRegion = r;\r\n    return true;\r\n  }\r\n\r\n  start(label:string){\r\n    if(!this.invRegion) return;\r\n\r\n    this.runState=\"running\";\r\n    this.captureAndUpdate(true);\r\n\r\n    this.timer = window.setInterval(()=>{\r\n      if(this.runState!==\"running\") return;\r\n      this.captureAndUpdate(false);\r\n    },600);\r\n\r\n    this.state.activeSession={\r\n      id:crypto.randomUUID(),\r\n      label,\r\n      startedAt:Date.now(),\r\n      endedAt:null,\r\n      loot:[]\r\n    };\r\n\r\n    this.updateCb?.();\r\n  }\r\n\r\n  togglePause(){\r\n    if(this.runState===\"idle\") return;\r\n    this.runState=this.runState===\"paused\"?\"running\":\"paused\";\r\n    this.updateCb?.();\r\n  }\r\n\r\n  stop(){\r\n    this.runState=\"idle\";\r\n    if(this.timer) clearInterval(this.timer);\r\n\r\n    const s=this.state.activeSession;\r\n    if(s){\r\n      s.endedAt=Date.now();\r\n      s.loot=this.getCurrentLoot();\r\n      this.state.sessions.unshift(s as Session);\r\n      this.state.activeSession=null;\r\n    }\r\n\r\n    this.updateCb?.();\r\n  }\r\n\r\n  private captureAndUpdate(isBaseline:boolean){\r\n    if(!this.invRegion) return;\r\n\r\n    const img:any = captureHoldFullRs();\r\n    if(!img) return;\r\n\r\n    const cols=4, rows=7;\r\n    const slotW=Math.floor(this.invRegion.w/cols);\r\n    const slotH=Math.floor(this.invRegion.h/rows);\r\n\r\n    for(let i=0;i<28;i++){\r\n      const col=i%cols;\r\n      const row=Math.floor(i/cols);\r\n\r\n      const sx=this.invRegion.x+col*slotW;\r\n      const sy=this.invRegion.y+row*slotH;\r\n\r\n      const icon:any = img.crop(sx+2,sy+Math.floor(slotH*0.22),slotW-4,slotH-4);\r\n      const num:any = img.crop(sx+1,sy+1,Math.floor(slotW*0.7),Math.floor(slotH*0.4));\r\n\r\n      const sig=aHash64(icon);\r\n      const qty=readStackNumber(num);\r\n\r\n      this.applySlotUpdate(i,sig,qty,isBaseline);\r\n    }\r\n\r\n    if(!isBaseline && this.moneyRegion){\r\n      const money:any=img.crop(this.moneyRegion.x,this.moneyRegion.y,this.moneyRegion.w,this.moneyRegion.h);\r\n      const gain=readMoneyGain(money);\r\n      if(gain) this.addLoot(\"coins:pouch\",\"Coins (Money Pouch)\",gain);\r\n    }\r\n\r\n    this.updateCb?.();\r\n  }\r\n\r\n  private applySlotUpdate(i:number,sig:string|null,qty:number|null,isBaseline:boolean){\r\n    const slot=this.slots[i];\r\n\r\n    if(!sig||qty===null) return;\r\n\r\n    const prevSig=slot.sig;\r\n    const prevQty=slot.qty;\r\n\r\n    slot.sig=sig;\r\n    slot.qty=qty;\r\n\r\n    if(isBaseline) return;\r\n\r\n    if(prevSig!==sig||prevQty===null){\r\n      this.addLoot(sig,this.displayName(sig),qty);\r\n      return;\r\n    }\r\n\r\n    if(qty>prevQty){\r\n      this.addLoot(sig,this.displayName(sig),qty-prevQty);\r\n    }\r\n  }\r\n\r\n  private addLoot(key:string,name:string,qty:number){\r\n    if(!this.loot[key]){\r\n      this.loot[key]={key,name,qty:0,iconSig:key};\r\n    }\r\n    this.loot[key].qty+=qty;\r\n\r\n    if(this.state.activeSession){\r\n      this.state.activeSession.loot=this.getCurrentLoot();\r\n    }\r\n  }\r\n\r\n  private displayName(sig:string){\r\n    return this.state.iconNames[sig] ?? `Unidentified (${sig.slice(0,6)})`;\r\n  }\r\n}"],"names":["__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","g","globalThis","this","Function","e","window","ImgRef","constructor","x","y","w","h","t","width","height","read","Error","findSubimage","needle","sx","sy","haystackImgref","needleBuffer","sw","sh","TypeError","ImgRefBind","alt1","bindFindSubImg","needlestr","buf","raw","i","String","fromCharCode","data","btoa","r","handle","JSON","parse","haystack","needlestride","heystackstride","checkList","push","length","cw","ch","checklength","outer","a","i1","i2","d","Math","abs","simpleCompare","Infinity","findSubbuffer","toData","containsArea","rect","super","round","requireAlt1","bindGetRegionBuffer","x1","x2","min","floor","maxtransfer","bindGetRegion","Alt1Error","decodeImageString","transferImageData","requireSharp","requireNodeCanvas","globalvar","self","filltype","ImageData","document","fillconstr","Uint8ClampedArray","constr","arguments","canvas","createElement","imageData","getContext","createImageData","set","prototype","toDrawableData","nodecnv","putImageData","cx","cy","dx","dy","pixelOffset","getPixelHash","hash","clone","toImage","getImageData","show","zoom","imgs","getElementsByClassName","maxImages","remove","el","classList","add","style","position","zIndex","left","top","background","cursor","imageRendering","outline","onclick","body","appendChild","console","error","createCanvas","getPixel","getPixelValueSum","getPixelInt","getColorDifference","b","setPixel","color","Array","isArray","setPixelInt","toFileBytes","format","quality","HTMLCanvasElement","Promise","toBlob","FileReader","readAsArrayBuffer","onload","Uint8Array","result","thisArg","_arguments","generator","electronCommon","sharp","requireElectronCommon","nativeImage","bufcpy","Buffer","from","slice","byteOffset","byteLength","tmp","flipBGRAtoRGBA","createFromBitmap","toPNG","img","buffer","channels","png","opts","webp","toBuffer","resolveWithObject","P","resolve","reject","fulfilled","value","step","next","rejected","done","then","apply","toPngBase64","str","toDataURL","indexOf","pixelCompare","max","copyTo","target","sourcex","sourcey","targetx","targety","targetwidth","thiswidth","copywidth","fastwidth","thisdata","Int32Array","targetdata","it","is","HTMLImageElement","cnv","ctx","drawImage","toCanvas","NoAlt1Error","message","hasAlt1","skinName","imagestring","bin","atob","bytes","offset","target_width","charCodeAt","bigbuf","checkbuf","RangeError","dif","fromArgs","args","union","r2","includePoint","inflate","intersect","overlaps","contains","containsPoint","debugFont","font","spacing","chars","bx","chr","pixels","shadow","canblend","rm","gm","bm","r1","g1","b1","p","m","unblend","R","G","B","sqrt","n","readChar","col","backwards","allowSecondary","basey","shifty","debugobj","debugimg","scores","chrobj","secondary","score","sizescore","chrx","penalty","lum","bonus","rawscore","sort","winchr","basechar","cleanDigits","s","replace","readLineText","res","colors","forward","backward","multicol","allcolors","detectcolor","bestscore","best","b2","pixel1","pixel2","getChatColor","fragments","maxspaces","fragtext","fraghadprimary","lastcol","addfrag","frag","text","index","xstart","fragstartdx","fragenddx","xend","unshift","dirforward","triedspaces","triedrecol","spacewidth","spaces","forEach","f","debugArea","map","join","readStackNumber","cleaned","Number","isFinite","aHash64","toString","async","getRegionFromAlt1","alt1Any","getRegion","lastRegion","KEY","setText","id","getElementById","textContent","state","localStorage","getItem","parsed","settings","invRegion","moneyRegion","iconNames","sessions","activeSession","loadAppState","tracker","runState","slots","sig","qty","loot","iconCache","timer","updateCb","onUpdate","cb","hasInventoryRegion","hasMoneyRegion","getRunState","getCurrentLoot","Object","values","getIconPngDataUrl","reset","calibrateInventoryRegion","calibrateMoneyRegion","start","label","captureAndUpdate","setInterval","crypto","randomUUID","startedAt","Date","now","endedAt","togglePause","stop","clearInterval","isBaseline","bindRegion","captureHold","rsWidth","rsHeight","slotW","slotH","row","icon","crop","num","applySlotUpdate","gain","includes","readMoneyGain","addLoot","slot","prevSig","prevQty","displayName","key","name","iconSig","btnCalibInv","btnCalibMoney","btnStart","btnPause","btnStop","btnClearAll","sessionLabel","refreshUI","disabled","entries","tbody","innerHTML","tr","dataset","tdIcon","className","alt","tdName","tdQty","toLocaleString","renderLootTable","tdWhen","tdLabel","tdCount","renderSessionTable","querySelectorAll","url","getIconUrl","src","ev","closest","existing","prompt","trim","wireClickRename","setItem","stringify","saveAppState","alert","confirm"],"sourceRoot":""}